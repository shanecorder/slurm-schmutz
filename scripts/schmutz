#!/usr/bin/env python3
"""
Schmutz - Slurm Job Efficiency Monitor for Open OnDemand

A standalone CLI utility for displaying Slurm job efficiency metrics,
inspired by jobstats and jobperf from Clemson University.

This is a self-contained script with no external dependencies beyond
Python 3.7+ standard library. PyYAML is optional for config file support.

Usage:
    schmutz <job_id>           Show efficiency for a job
    schmutz status <job_id>    Same as above
    schmutz update <job_id>    Update OOD session card for job
    schmutz list               List active OOD sessions
    schmutz html <job_id>      Generate HTML card output

Drop this file into a shared location (e.g., /opt/slurm/bin/schmutz),
make it executable (chmod +x), and all users can run it.
"""

import sys

# Version check - must be before other imports that require 3.7+
if sys.version_info < (3, 7):
    sys.exit(
        f"Error: schmutz requires Python 3.7 or later.\n"
        f"You are running Python {sys.version_info.major}.{sys.version_info.minor}.\n"
        f"Try: module load python/3.8 (or similar) before running schmutz."
    )

__version__ = "1.0.1"

import argparse
import json
import logging
import os
import pwd
import re
import subprocess
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

# Try to import yaml, but make it optional
try:
    import yaml
    HAS_YAML = True
except ImportError:
    HAS_YAML = False

logger = logging.getLogger(__name__)


# =============================================================================
# Configuration Classes
# =============================================================================

@dataclass
class EfficiencyThresholds:
    """Thresholds for color-coded efficiency indicators."""
    cpu_good: float = 80.0
    cpu_warning: float = 50.0
    memory_good: float = 70.0
    memory_warning: float = 40.0
    gpu_good: float = 70.0
    gpu_warning: float = 40.0
    gpu_memory_good: float = 50.0
    gpu_memory_warning: float = 25.0


def _find_command(name: str) -> str:
    """Find command path, checking common locations."""
    import shutil
    
    # Common Slurm installation paths (checked in order)
    common_paths = [
        '/usr/bin',
        '/usr/local/bin', 
        '/opt/slurm/bin',
        '/cm/shared/apps/slurm/current/bin',
        '/cm/local/apps/slurm/current/bin',
        '/apps/slurm/bin',
        '/usr/local/slurm/bin',
        '/opt/ohpc/pub/slurm/bin',
    ]
    
    # Check common locations first (more reliable than user's potentially modified PATH)
    for prefix in common_paths:
        candidate = os.path.join(prefix, name)
        if os.path.isfile(candidate) and os.access(candidate, os.X_OK):
            return candidate
    
    # Try to find in PATH as fallback
    path = shutil.which(name)
    if path:
        return path
    
    # Last resort: return the bare command name and hope it's in PATH at runtime
    return name


@dataclass
class SlurmConfig:
    """Slurm-related configuration."""
    sstat_path: str = field(default_factory=lambda: _find_command('sstat'))
    sacct_path: str = field(default_factory=lambda: _find_command('sacct'))
    squeue_path: str = field(default_factory=lambda: _find_command('squeue'))
    scontrol_path: str = field(default_factory=lambda: _find_command('scontrol'))
    sinfo_path: str = field(default_factory=lambda: _find_command('sinfo'))
    command_timeout: int = 30
    
    def __post_init__(self):
        """Ensure all paths are valid strings, not None."""
        if not self.sstat_path:
            self.sstat_path = _find_command('sstat')
        if not self.sacct_path:
            self.sacct_path = _find_command('sacct')
        if not self.squeue_path:
            self.squeue_path = _find_command('squeue')
        if not self.scontrol_path:
            self.scontrol_path = _find_command('scontrol')
        if not self.sinfo_path:
            self.sinfo_path = _find_command('sinfo')


@dataclass
class Config:
    """Main configuration class for Schmutz."""
    ood_data_root: str = "/var/lib/ondemand-nginx"
    session_data_dir: str = "data/sys/dashboard/batch_connect/db"
    log_level: str = "INFO"
    log_file: Optional[str] = None
    thresholds: EfficiencyThresholds = field(default_factory=EfficiencyThresholds)
    slurm: SlurmConfig = field(default_factory=SlurmConfig)
    card_title: str = "Job Efficiency"
    show_recommendations: bool = True
    compact_mode: bool = False

    @classmethod
    def from_yaml(cls, config_path: str) -> "Config":
        """Load configuration from a YAML file."""
        if not HAS_YAML:
            logger.warning("PyYAML not installed, using default configuration")
            return cls()
        
        config_file = Path(config_path)
        if not config_file.exists():
            logger.warning(f"Config file not found: {config_path}, using defaults")
            return cls()

        try:
            with open(config_file, 'r') as f:
                data = yaml.safe_load(f) or {}
            return cls.from_dict(data)
        except Exception as e:
            logger.error(f"Error parsing config file: {e}")
            return cls()

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Config":
        """Create configuration from a dictionary."""
        thresholds_data = data.pop('thresholds', {})
        slurm_data = data.pop('slurm', {})
        # Filter out None values to preserve defaults
        thresholds_data = {k: v for k, v in thresholds_data.items() if v is not None}
        slurm_data = {k: v for k, v in slurm_data.items() if v is not None}
        thresholds = EfficiencyThresholds(**thresholds_data) if thresholds_data else EfficiencyThresholds()
        slurm = SlurmConfig(**slurm_data) if slurm_data else SlurmConfig()
        return cls(
            thresholds=thresholds,
            slurm=slurm,
            **{k: v for k, v in data.items() if k in cls.__dataclass_fields__ and v is not None}
        )

    def get_user_session_path(self, username: str) -> Path:
        """Get the OOD session data path for a specific user."""
        return Path(self.ood_data_root) / username / self.session_data_dir


def get_default_config_paths() -> List[str]:
    """Return list of default configuration file paths to check."""
    return [
        "/etc/schmutz/config.yaml",
        "/etc/schmutz/config.yml",
        os.path.expanduser("~/.config/schmutz/config.yaml"),
        os.path.expanduser("~/.config/schmutz/config.yml"),
        "./config/config.yaml",
        "./config.yaml",
    ]


def load_config(config_path: Optional[str] = None) -> Config:
    """Load configuration from file or use defaults."""
    if config_path:
        return Config.from_yaml(config_path)
    for path in get_default_config_paths():
        if os.path.exists(path):
            logger.info(f"Loading config from: {path}")
            return Config.from_yaml(path)
    logger.debug("No config file found, using defaults")
    return Config()


# =============================================================================
# Job Statistics Classes
# =============================================================================

class JobState(Enum):
    """Slurm job states."""
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"
    TIMEOUT = "TIMEOUT"
    NODE_FAIL = "NODE_FAIL"
    PREEMPTED = "PREEMPTED"
    UNKNOWN = "UNKNOWN"

    @classmethod
    def from_string(cls, state_str: str) -> "JobState":
        """Convert Slurm state string to enum."""
        state_str = state_str.upper().split()[0]
        try:
            return cls(state_str)
        except ValueError:
            return cls.UNKNOWN

    @property
    def is_running(self) -> bool:
        return self == JobState.RUNNING

    @property
    def is_completed(self) -> bool:
        return self in (JobState.COMPLETED, JobState.FAILED, JobState.CANCELLED,
                       JobState.TIMEOUT, JobState.NODE_FAIL, JobState.PREEMPTED)

    @property
    def is_successful(self) -> bool:
        return self == JobState.COMPLETED


@dataclass
class GPUMetrics:
    """GPU utilization metrics."""
    gpu_id: int = 0
    gpu_name: str = ""
    utilization: float = 0.0
    memory_used: float = 0.0
    memory_total: float = 0.0
    memory_utilization: float = 0.0

    @property
    def memory_used_gb(self) -> float:
        return self.memory_used / (1024 ** 3)

    @property
    def memory_total_gb(self) -> float:
        return self.memory_total / (1024 ** 3)


@dataclass
class JobMetrics:
    """Complete job metrics including efficiency calculations."""
    job_id: str = ""
    job_name: str = ""
    user: str = ""
    state: JobState = JobState.UNKNOWN
    submit_time: Optional[datetime] = None
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    elapsed_time: timedelta = field(default_factory=timedelta)
    time_limit: timedelta = field(default_factory=timedelta)
    num_nodes: int = 0
    num_cpus: int = 0
    num_gpus: int = 0
    memory_requested: float = 0.0
    partition: str = ""
    cpu_time_total: float = 0.0
    cpu_efficiency: float = 0.0
    memory_used_max: float = 0.0
    memory_used_avg: float = 0.0
    memory_efficiency: float = 0.0
    gpu_utilization_avg: float = 0.0
    gpu_memory_utilization_avg: float = 0.0
    gpu_metrics: List[GPUMetrics] = field(default_factory=list)
    last_updated: Optional[datetime] = None
    error_message: Optional[str] = None

    @property
    def elapsed_seconds(self) -> float:
        return self.elapsed_time.total_seconds()

    @property
    def time_limit_seconds(self) -> float:
        return self.time_limit.total_seconds()

    @property
    def time_efficiency(self) -> float:
        if self.time_limit_seconds <= 0:
            return 0.0
        return (self.elapsed_seconds / self.time_limit_seconds) * 100

    @property
    def memory_requested_gb(self) -> float:
        return self.memory_requested / (1024 ** 3)

    @property
    def memory_used_max_gb(self) -> float:
        return self.memory_used_max / (1024 ** 3)

    @property
    def has_gpus(self) -> bool:
        return self.num_gpus > 0

    def calculate_efficiency(self) -> None:
        """Calculate efficiency metrics from raw data."""
        if self.elapsed_seconds > 0 and self.num_cpus > 0:
            max_cpu_time = self.elapsed_seconds * self.num_cpus
            self.cpu_efficiency = (self.cpu_time_total / max_cpu_time) * 100
            self.cpu_efficiency = min(100.0, max(0.0, self.cpu_efficiency))
        if self.memory_requested > 0:
            self.memory_efficiency = (self.memory_used_max / self.memory_requested) * 100
            self.memory_efficiency = min(100.0, max(0.0, self.memory_efficiency))
        if self.gpu_metrics:
            self.gpu_utilization_avg = sum(g.utilization for g in self.gpu_metrics) / len(self.gpu_metrics)
            self.gpu_memory_utilization_avg = sum(g.memory_utilization for g in self.gpu_metrics) / len(self.gpu_metrics)


class JobStats:
    """Collects job statistics from Slurm."""

    def __init__(self, config: Optional[Config] = None):
        self.config = config or Config()
        self.slurm = self.config.slurm

    def _run_command(self, cmd: List[str], timeout: Optional[int] = None) -> Tuple[str, str, int]:
        """Run a shell command and return output."""
        timeout = timeout or self.slurm.command_timeout
        
        # Validate command list - convert all elements to strings and check for None
        try:
            cmd = [str(c) if c is not None else '' for c in cmd]
            if not cmd or not cmd[0]:
                logger.error("Empty or invalid command")
                return "", "Empty or invalid command", -1
        except (TypeError, ValueError) as e:
            logger.error(f"Invalid command format: {e}")
            return "", f"Invalid command format: {e}", -1
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
            return result.stdout, result.stderr, result.returncode
        except subprocess.TimeoutExpired:
            logger.error(f"Command timed out: {' '.join(cmd)}")
            return "", "Command timed out", -1
        except FileNotFoundError:
            logger.error(f"Command not found: {cmd[0]}")
            return "", f"Command not found: {cmd[0]}", -1
        except Exception as e:
            logger.error(f"Error running command {' '.join(cmd)}: {e}")
            return "", str(e), -1

    def get_job_state(self, job_id: str) -> JobState:
        """Get the current state of a job."""
        cmd = [self.slurm.squeue_path, "-j", job_id, "--noheader", "-o", "%T"]
        stdout, stderr, rc = self._run_command(cmd)
        if rc == 0 and stdout.strip():
            return JobState.from_string(stdout.strip())
        cmd = [self.slurm.sacct_path, "-j", job_id, "--noheader", "-P", "-o", "State", "-n"]
        stdout, stderr, rc = self._run_command(cmd)
        if rc == 0 and stdout.strip():
            states = stdout.strip().split('\n')
            if states:
                return JobState.from_string(states[0])
        return JobState.UNKNOWN

    def _parse_memory(self, mem_str: str) -> float:
        """Parse Slurm memory string to bytes."""
        if not mem_str or mem_str == "":
            return 0.0
        mem_str = mem_str.strip().upper()
        multipliers = {'K': 1024, 'M': 1024 ** 2, 'G': 1024 ** 3, 'T': 1024 ** 4}
        match = re.match(r'^([\d.]+)([KMGT]?)$', mem_str)
        if match:
            value = float(match.group(1))
            suffix = match.group(2)
            return value * multipliers.get(suffix, 1)
        try:
            return float(mem_str)
        except ValueError:
            logger.warning(f"Could not parse memory value: {mem_str}")
            return 0.0

    def _parse_time(self, time_str: str) -> timedelta:
        """Parse Slurm time string to timedelta."""
        if not time_str or time_str == "":
            return timedelta()
        time_str = time_str.strip()
        days = 0
        if '-' in time_str:
            days_part, time_str = time_str.split('-', 1)
            days = int(days_part)
        parts = time_str.split(':')
        try:
            if len(parts) == 3:
                hours, minutes, seconds = map(float, parts)
            elif len(parts) == 2:
                hours = 0
                minutes, seconds = map(float, parts)
            elif len(parts) == 1:
                hours = 0
                minutes = 0
                seconds = float(parts[0])
            else:
                return timedelta()
            return timedelta(days=days, hours=hours, minutes=minutes, seconds=seconds)
        except ValueError:
            logger.warning(f"Could not parse time value: {time_str}")
            return timedelta()

    def _parse_datetime(self, dt_str: str) -> Optional[datetime]:
        """Parse Slurm datetime string."""
        if not dt_str or dt_str in ("Unknown", "None", "N/A"):
            return None
        formats = ["%Y-%m-%dT%H:%M:%S", "%Y-%m-%d %H:%M:%S", "%Y-%m-%dT%H:%M:%S.%f"]
        for fmt in formats:
            try:
                return datetime.strptime(dt_str.strip(), fmt)
            except ValueError:
                continue
        logger.warning(f"Could not parse datetime: {dt_str}")
        return None

    def _parse_cpu_time(self, cpu_time_str: str) -> float:
        """Parse CPU time to seconds."""
        td = self._parse_time(cpu_time_str)
        return td.total_seconds()

    def get_running_job_stats(self, job_id: str) -> Optional[JobMetrics]:
        """Get statistics for a running job using sstat."""
        metrics = JobMetrics(job_id=job_id, state=JobState.RUNNING)
        metrics.last_updated = datetime.now()

        squeue_cmd = [
            self.slurm.squeue_path, "-j", job_id, "--noheader",
            "-o", "%j|%u|%T|%V|%S|%L|%D|%C|%b|%m|%P"
        ]
        stdout, stderr, rc = self._run_command(squeue_cmd)
        if rc != 0 or not stdout.strip():
            logger.warning(f"Job {job_id} not found in squeue")
            return None

        parts = stdout.strip().split('|')
        if len(parts) >= 11:
            metrics.job_name = parts[0]
            metrics.user = parts[1]
            metrics.state = JobState.from_string(parts[2])
            metrics.submit_time = self._parse_datetime(parts[3])
            metrics.start_time = self._parse_datetime(parts[4])
            time_left = self._parse_time(parts[5])
            metrics.num_nodes = int(parts[6]) if parts[6].isdigit() else 1
            metrics.num_cpus = int(parts[7]) if parts[7].isdigit() else 1
            gres = parts[8]
            if 'gpu' in gres.lower():
                match = re.search(r'gpu[:\w]*:(\d+)', gres.lower())
                if match:
                    metrics.num_gpus = int(match.group(1))
            metrics.memory_requested = self._parse_memory(parts[9])
            metrics.partition = parts[10]
            if metrics.start_time:
                metrics.elapsed_time = datetime.now() - metrics.start_time
                metrics.time_limit = metrics.elapsed_time + time_left

        for step_suffix in ["", ".batch", ".0"]:
            sstat_cmd = [
                self.slurm.sstat_path, "-j", f"{job_id}{step_suffix}",
                "--noheader", "-P", "-o", "JobID,AveCPU,MaxRSS,MaxVMSize,NTasks"
            ]
            stdout, stderr, rc = self._run_command(sstat_cmd)
            if rc == 0 and stdout.strip():
                for line in stdout.strip().split('\n'):
                    parts = line.split('|')
                    if len(parts) >= 5:
                        metrics.cpu_time_total = self._parse_cpu_time(parts[1])
                        metrics.memory_used_max = self._parse_memory(parts[2])
                        break
                break

        metrics.calculate_efficiency()
        return metrics

    def get_completed_job_stats(self, job_id: str) -> Optional[JobMetrics]:
        """Get statistics for a completed job using sacct."""
        metrics = JobMetrics(job_id=job_id)
        metrics.last_updated = datetime.now()

        sacct_cmd = [
            self.slurm.sacct_path, "-j", job_id, "--noheader", "-P",
            "-o", "JobID,JobName,User,State,Submit,Start,End,Elapsed,Timelimit,"
                  "NNodes,NCPUs,ReqMem,MaxRSS,AveCPU,TotalCPU,Partition,AllocTRES,ExitCode"
        ]
        stdout, stderr, rc = self._run_command(sacct_cmd)
        if rc != 0 or not stdout.strip():
            logger.warning(f"Job {job_id} not found in sacct: {stderr}")
            return None

        lines = stdout.strip().split('\n')
        main_line = None
        batch_line = None
        for line in lines:
            parts = line.split('|')
            if parts:
                step_id = parts[0]
                if step_id == job_id or step_id == f"{job_id}.batch":
                    if '.batch' in step_id:
                        batch_line = parts
                    else:
                        main_line = parts

        if not main_line:
            main_line = lines[0].split('|') if lines else None
        if not main_line or len(main_line) < 18:
            logger.warning(f"Incomplete sacct output for job {job_id}")
            return None

        metrics.job_name = main_line[1]
        metrics.user = main_line[2]
        metrics.state = JobState.from_string(main_line[3])
        metrics.submit_time = self._parse_datetime(main_line[4])
        metrics.start_time = self._parse_datetime(main_line[5])
        metrics.end_time = self._parse_datetime(main_line[6])
        metrics.elapsed_time = self._parse_time(main_line[7])
        metrics.time_limit = self._parse_time(main_line[8])
        metrics.num_nodes = int(main_line[9]) if main_line[9].isdigit() else 1
        metrics.num_cpus = int(main_line[10]) if main_line[10].isdigit() else 1

        req_mem = main_line[11]
        mem_multiplier = 1
        if req_mem.endswith('n'):
            mem_multiplier = metrics.num_nodes
            req_mem = req_mem[:-1]
        elif req_mem.endswith('c'):
            mem_multiplier = metrics.num_cpus
            req_mem = req_mem[:-1]
        metrics.memory_requested = self._parse_memory(req_mem) * mem_multiplier
        metrics.partition = main_line[15]

        alloc_gres = main_line[16] if len(main_line) > 16 else ""
        if 'gpu' in alloc_gres.lower():
            match = re.search(r'gpu[:\w]*:(\d+)', alloc_gres.lower())
            if match:
                metrics.num_gpus = int(match.group(1))

        if batch_line and len(batch_line) >= 15:
            metrics.memory_used_max = self._parse_memory(batch_line[12])
            metrics.cpu_time_total = self._parse_cpu_time(batch_line[14])
        else:
            metrics.memory_used_max = self._parse_memory(main_line[12])
            metrics.cpu_time_total = self._parse_cpu_time(main_line[14])

        metrics.calculate_efficiency()
        return metrics

    def get_job_stats(self, job_id: str) -> Optional[JobMetrics]:
        """Get job statistics regardless of job state."""
        state = self.get_job_state(job_id)
        if state.is_running:
            return self.get_running_job_stats(job_id)
        elif state.is_completed:
            return self.get_completed_job_stats(job_id)
        elif state == JobState.PENDING:
            metrics = JobMetrics(job_id=job_id, state=state)
            metrics.last_updated = datetime.now()
            return metrics
        else:
            result = self.get_completed_job_stats(job_id)
            if result:
                return result
            return self.get_running_job_stats(job_id)


# =============================================================================
# Session Card Updater
# =============================================================================

class SessionCardUpdater:
    """Updates Open OnDemand session cards with job efficiency information."""

    CARD_STYLES = """
<style>
.job-efficiency-card {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 13px;
    line-height: 1.4;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 6px;
    margin: 8px 0;
}
.job-efficiency-card h4 {
    margin: 0 0 10px 0;
    padding-bottom: 6px;
    border-bottom: 1px solid #dee2e6;
    color: #495057;
    font-size: 14px;
}
.efficiency-section {
    margin-bottom: 10px;
}
.efficiency-section:last-child {
    margin-bottom: 0;
}
.efficiency-label {
    font-weight: 500;
    color: #6c757d;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.efficiency-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
}
.efficiency-value {
    font-weight: 600;
    font-size: 14px;
}
.efficiency-bar {
    height: 6px;
    background: #e9ecef;
    border-radius: 3px;
    overflow: hidden;
    margin-top: 2px;
}
.efficiency-bar-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.3s ease;
}
.efficiency-good { color: #28a745; }
.efficiency-warning { color: #ffc107; }
.efficiency-poor { color: #dc3545; }
.efficiency-neutral { color: #6c757d; }
.bar-good { background: #28a745; }
.bar-warning { background: #ffc107; }
.bar-poor { background: #dc3545; }
.recommendation {
    margin-top: 10px;
    padding: 8px;
    background: #fff3cd;
    border: 1px solid #ffc107;
    border-radius: 4px;
    font-size: 12px;
    color: #856404;
}
.recommendation.good {
    background: #d4edda;
    border-color: #28a745;
    color: #155724;
}
.job-summary {
    margin-top: 10px;
    padding: 8px;
    background: #e9ecef;
    border-radius: 4px;
}
.job-summary-row {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    padding: 2px 0;
}
.last-updated {
    font-size: 10px;
    color: #adb5bd;
    text-align: right;
    margin-top: 8px;
}
.compact .efficiency-row {
    padding: 2px 0;
}
.compact .efficiency-section {
    margin-bottom: 6px;
}
</style>
"""

    def __init__(self, config: Optional[Config] = None):
        self.config = config or Config()
        self.thresholds = self.config.thresholds

    def _get_efficiency_class(self, value: float, good_threshold: float,
                              warning_threshold: float, invert: bool = False) -> str:
        """Get CSS class for efficiency value based on thresholds."""
        if invert:
            if value >= good_threshold:
                return "poor"
            elif value >= warning_threshold:
                return "warning"
            else:
                return "good"
        else:
            if value >= good_threshold:
                return "good"
            elif value >= warning_threshold:
                return "warning"
            else:
                return "poor"

    def _format_duration(self, td: timedelta) -> str:
        """Format timedelta as human-readable string."""
        total_seconds = int(td.total_seconds())
        if total_seconds < 0:
            return "N/A"
        days = total_seconds // 86400
        hours = (total_seconds % 86400) // 3600
        minutes = (total_seconds % 3600) // 60
        seconds = total_seconds % 60
        parts = []
        if days > 0:
            parts.append(f"{days}d")
        if hours > 0 or days > 0:
            parts.append(f"{hours}h")
        if minutes > 0 or hours > 0 or days > 0:
            parts.append(f"{minutes}m")
        parts.append(f"{seconds}s")
        return " ".join(parts[:3])

    def _format_memory(self, bytes_val: float) -> str:
        """Format bytes as human-readable string."""
        if bytes_val <= 0:
            return "N/A"
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if abs(bytes_val) < 1024.0:
                return f"{bytes_val:.1f} {unit}"
            bytes_val /= 1024.0
        return f"{bytes_val:.1f} PB"

    def _generate_progress_bar(self, value: float, css_class: str) -> str:
        """Generate HTML for a progress bar."""
        value = max(0, min(100, value))
        return f'''
        <div class="efficiency-bar">
            <div class="efficiency-bar-fill bar-{css_class}" style="width: {value:.1f}%"></div>
        </div>
        '''

    def _generate_recommendations(self, metrics: JobMetrics) -> List[str]:
        """Generate efficiency recommendations based on metrics."""
        recommendations = []
        if metrics.cpu_efficiency < self.thresholds.cpu_warning:
            recommendations.append(
                f"‚ö†Ô∏è CPU efficiency is low ({metrics.cpu_efficiency:.1f}%). "
                f"Consider requesting fewer CPUs or optimizing CPU usage."
            )
        if metrics.memory_efficiency > 0:
            if metrics.memory_efficiency < self.thresholds.memory_warning:
                recommendations.append(
                    f"‚ö†Ô∏è Memory usage is low ({metrics.memory_efficiency:.1f}%). "
                    f"Consider requesting less memory to improve job scheduling."
                )
            elif metrics.memory_efficiency > 95:
                recommendations.append(
                    f"‚ö†Ô∏è Memory usage is very high ({metrics.memory_efficiency:.1f}%). "
                    f"Consider requesting more memory to avoid out-of-memory errors."
                )
        if metrics.has_gpus and metrics.gpu_utilization_avg > 0:
            if metrics.gpu_utilization_avg < self.thresholds.gpu_warning:
                recommendations.append(
                    f"‚ö†Ô∏è GPU utilization is low ({metrics.gpu_utilization_avg:.1f}%). "
                    f"Ensure your code is properly utilizing GPUs."
                )
        if metrics.time_efficiency > 0 and metrics.time_efficiency < 10:
            recommendations.append(
                f"‚ÑπÔ∏è Job completed using only {metrics.time_efficiency:.1f}% of the time limit. "
                f"Consider reducing the time limit for better scheduling priority."
            )
        return recommendations

    def generate_running_card_html(self, metrics: JobMetrics) -> str:
        """Generate HTML card content for a running job."""
        compact_class = "compact" if self.config.compact_mode else ""
        cpu_class = self._get_efficiency_class(
            metrics.cpu_efficiency, self.thresholds.cpu_good, self.thresholds.cpu_warning
        )
        mem_class = self._get_efficiency_class(
            metrics.memory_efficiency, self.thresholds.memory_good, self.thresholds.memory_warning
        )

        html = f"""
{self.CARD_STYLES}
<div class="job-efficiency-card {compact_class}">
    <h4>üìä {self.config.card_title}</h4>
    
    <div class="efficiency-section">
        <div class="efficiency-label">CPU Efficiency</div>
        <div class="efficiency-row">
            <span>Utilization</span>
            <span class="efficiency-value efficiency-{cpu_class}">{metrics.cpu_efficiency:.1f}%</span>
        </div>
        {self._generate_progress_bar(metrics.cpu_efficiency, cpu_class)}
    </div>
    
    <div class="efficiency-section">
        <div class="efficiency-label">Memory Usage</div>
        <div class="efficiency-row">
            <span>{self._format_memory(metrics.memory_used_max)} / {self._format_memory(metrics.memory_requested)}</span>
            <span class="efficiency-value efficiency-{mem_class}">{metrics.memory_efficiency:.1f}%</span>
        </div>
        {self._generate_progress_bar(metrics.memory_efficiency, mem_class)}
    </div>
"""

        if metrics.has_gpus:
            gpu_class = self._get_efficiency_class(
                metrics.gpu_utilization_avg, self.thresholds.gpu_good, self.thresholds.gpu_warning
            )
            gpu_mem_class = self._get_efficiency_class(
                metrics.gpu_memory_utilization_avg, self.thresholds.gpu_memory_good, self.thresholds.gpu_memory_warning
            )
            html += f"""
    <div class="efficiency-section">
        <div class="efficiency-label">GPU Utilization ({metrics.num_gpus} GPU{'s' if metrics.num_gpus > 1 else ''})</div>
        <div class="efficiency-row">
            <span>Compute</span>
            <span class="efficiency-value efficiency-{gpu_class}">{metrics.gpu_utilization_avg:.1f}%</span>
        </div>
        {self._generate_progress_bar(metrics.gpu_utilization_avg, gpu_class)}
        <div class="efficiency-row">
            <span>Memory</span>
            <span class="efficiency-value efficiency-{gpu_mem_class}">{metrics.gpu_memory_utilization_avg:.1f}%</span>
        </div>
        {self._generate_progress_bar(metrics.gpu_memory_utilization_avg, gpu_mem_class)}
    </div>
"""

        html += f"""
    <div class="job-summary">
        <div class="job-summary-row">
            <span>Elapsed Time:</span>
            <span>{self._format_duration(metrics.elapsed_time)}</span>
        </div>
        <div class="job-summary-row">
            <span>Time Limit:</span>
            <span>{self._format_duration(metrics.time_limit)}</span>
        </div>
        <div class="job-summary-row">
            <span>Resources:</span>
            <span>{metrics.num_nodes}N √ó {metrics.num_cpus}C</span>
        </div>
    </div>
"""

        if self.config.show_recommendations:
            recommendations = self._generate_recommendations(metrics)
            if recommendations:
                html += """
    <div class="recommendation">
        <strong>Tips:</strong><br>
"""
                for rec in recommendations:
                    html += f"        {rec}<br>\n"
                html += "    </div>\n"

        updated_str = metrics.last_updated.strftime("%H:%M:%S") if metrics.last_updated else "Unknown"
        html += f"""
    <div class="last-updated">Last updated: {updated_str}</div>
</div>
"""
        return html

    def generate_completed_card_html(self, metrics: JobMetrics) -> str:
        """Generate HTML card content for a completed job."""
        compact_class = "compact" if self.config.compact_mode else ""

        if metrics.state.is_successful:
            status_icon = "‚úÖ"
            status_text = "Completed Successfully"
        elif metrics.state == JobState.CANCELLED:
            status_icon = "üö´"
            status_text = "Cancelled"
        elif metrics.state == JobState.TIMEOUT:
            status_icon = "‚è±Ô∏è"
            status_text = "Timed Out"
        else:
            status_icon = "‚ùå"
            status_text = f"Failed ({metrics.state.value})"

        cpu_class = self._get_efficiency_class(
            metrics.cpu_efficiency, self.thresholds.cpu_good, self.thresholds.cpu_warning
        )
        mem_class = self._get_efficiency_class(
            metrics.memory_efficiency, self.thresholds.memory_good, self.thresholds.memory_warning
        )

        html = f"""
{self.CARD_STYLES}
<div class="job-efficiency-card {compact_class}">
    <h4>{status_icon} Job {status_text}</h4>
    
    <div class="job-summary">
        <div class="job-summary-row">
            <span>Job ID:</span>
            <span>{metrics.job_id}</span>
        </div>
        <div class="job-summary-row">
            <span>Total Runtime:</span>
            <span>{self._format_duration(metrics.elapsed_time)}</span>
        </div>
        <div class="job-summary-row">
            <span>Time Limit:</span>
            <span>{self._format_duration(metrics.time_limit)} ({metrics.time_efficiency:.1f}% used)</span>
        </div>
        <div class="job-summary-row">
            <span>Resources:</span>
            <span>{metrics.num_nodes}N √ó {metrics.num_cpus}C{f' √ó {metrics.num_gpus}G' if metrics.has_gpus else ''}</span>
        </div>
    </div>
    
    <div class="efficiency-section">
        <div class="efficiency-label">Final CPU Efficiency</div>
        <div class="efficiency-row">
            <span>Overall</span>
            <span class="efficiency-value efficiency-{cpu_class}">{metrics.cpu_efficiency:.1f}%</span>
        </div>
        {self._generate_progress_bar(metrics.cpu_efficiency, cpu_class)}
    </div>
    
    <div class="efficiency-section">
        <div class="efficiency-label">Final Memory Usage</div>
        <div class="efficiency-row">
            <span>Peak: {self._format_memory(metrics.memory_used_max)} / {self._format_memory(metrics.memory_requested)}</span>
            <span class="efficiency-value efficiency-{mem_class}">{metrics.memory_efficiency:.1f}%</span>
        </div>
        {self._generate_progress_bar(metrics.memory_efficiency, mem_class)}
    </div>
"""

        if metrics.has_gpus:
            gpu_class = self._get_efficiency_class(
                metrics.gpu_utilization_avg, self.thresholds.gpu_good, self.thresholds.gpu_warning
            )
            html += f"""
    <div class="efficiency-section">
        <div class="efficiency-label">GPU Summary ({metrics.num_gpus} GPU{'s' if metrics.num_gpus > 1 else ''})</div>
        <div class="efficiency-row">
            <span>Average Utilization</span>
            <span class="efficiency-value efficiency-{gpu_class}">{metrics.gpu_utilization_avg:.1f}%</span>
        </div>
        {self._generate_progress_bar(metrics.gpu_utilization_avg, gpu_class)}
    </div>
"""

        if self.config.show_recommendations:
            recommendations = self._generate_recommendations(metrics)
            if recommendations:
                html += """
    <div class="recommendation">
        <strong>Suggestions for Future Jobs:</strong><br>
"""
                for rec in recommendations:
                    html += f"        {rec}<br>\n"
                html += "    </div>\n"
            elif metrics.cpu_efficiency > self.thresholds.cpu_good and metrics.memory_efficiency > self.thresholds.memory_warning:
                html += """
    <div class="recommendation good">
        ‚ú® Great job! Resource utilization was efficient.
    </div>
"""

        html += "</div>\n"
        return html

    def generate_card_html(self, metrics: JobMetrics) -> str:
        """Generate appropriate HTML card based on job state."""
        if metrics.state.is_completed:
            return self.generate_completed_card_html(metrics)
        else:
            return self.generate_running_card_html(metrics)

    def update_session_card(self, session_path: Path, metrics: JobMetrics) -> bool:
        """Update the session card HTML file with job efficiency data."""
        info_html_path = session_path / "info.html"
        try:
            new_content = self.generate_card_html(metrics)
            with open(info_html_path, 'w') as f:
                f.write(new_content)
            logger.debug(f"Updated session card: {info_html_path}")
            return True
        except PermissionError:
            logger.error(f"Permission denied writing to: {info_html_path}")
            return False
        except Exception as e:
            logger.error(f"Error updating session card: {e}")
            return False

    def find_session_for_job(self, user: str, job_id: str) -> Optional[Path]:
        """Find the OOD session directory for a given Slurm job."""
        user_session_path = self.config.get_user_session_path(user)
        if not user_session_path.exists():
            logger.debug(f"User session path does not exist: {user_session_path}")
            return None
        for session_dir in user_session_path.iterdir():
            if not session_dir.is_dir():
                continue
            job_id_file = session_dir / "job_id"
            if job_id_file.exists():
                try:
                    with open(job_id_file, 'r') as f:
                        stored_job_id = f.read().strip()
                    if stored_job_id == job_id:
                        return session_dir
                except Exception as e:
                    logger.debug(f"Error reading job_id file: {e}")
                    continue
        logger.debug(f"No session found for job {job_id}")
        return None

    def list_active_sessions(self, user: str) -> List[tuple]:
        """List all active OOD sessions for a user."""
        sessions = []
        user_session_path = self.config.get_user_session_path(user)
        if not user_session_path.exists():
            return sessions
        for session_dir in user_session_path.iterdir():
            if not session_dir.is_dir():
                continue
            job_id_file = session_dir / "job_id"
            if job_id_file.exists():
                try:
                    with open(job_id_file, 'r') as f:
                        job_id = f.read().strip()
                    sessions.append((session_dir, job_id))
                except Exception:
                    continue
        return sessions


# =============================================================================
# CLI Commands
# =============================================================================

def setup_logging(verbose: bool = False, debug: bool = False) -> None:
    """Configure logging based on command line options."""
    if debug:
        level = logging.DEBUG
    elif verbose:
        level = logging.INFO
    else:
        level = logging.WARNING
    logging.basicConfig(level=level, format='%(levelname)s: %(message)s')


def _make_bar(value: float, width: int = 20) -> str:
    """Create a simple ASCII progress bar."""
    value = max(0, min(100, value))
    filled = int(width * value / 100)
    empty = width - filled
    return f"[{'‚ñà' * filled}{'‚ñë' * empty}]"


def _get_recommendations(metrics: JobMetrics, config: Config) -> List[str]:
    """Generate efficiency recommendations."""
    recs = []
    thresholds = config.thresholds
    if metrics.cpu_efficiency < thresholds.cpu_warning and metrics.cpu_efficiency > 0:
        recs.append(f"Low CPU efficiency ({metrics.cpu_efficiency:.0f}%). Consider requesting fewer CPUs.")
    if metrics.memory_efficiency < thresholds.memory_warning and metrics.memory_efficiency > 0:
        recs.append(f"Low memory usage ({metrics.memory_efficiency:.0f}%). Consider requesting less memory.")
    elif metrics.memory_efficiency > 95:
        recs.append(f"High memory usage ({metrics.memory_efficiency:.0f}%). Consider requesting more memory.")
    if metrics.has_gpus and metrics.gpu_utilization_avg < thresholds.gpu_warning and metrics.gpu_utilization_avg > 0:
        recs.append(f"Low GPU utilization ({metrics.gpu_utilization_avg:.0f}%). Ensure code is GPU-optimized.")
    if metrics.state.is_completed and metrics.time_efficiency < 25:
        recs.append(f"Only used {metrics.time_efficiency:.0f}% of time limit. Request less time for faster scheduling.")
    return recs


@dataclass
class ReportStats:
    """Aggregated statistics for a report."""
    total_jobs: int = 0
    completed_jobs: int = 0
    failed_jobs: int = 0
    cancelled_jobs: int = 0
    total_cpu_hours_requested: float = 0.0
    total_cpu_hours_used: float = 0.0
    total_memory_gb_hours_requested: float = 0.0
    total_memory_gb_hours_used: float = 0.0
    total_gpu_hours_requested: float = 0.0
    avg_cpu_efficiency: float = 0.0
    avg_memory_efficiency: float = 0.0
    avg_time_efficiency: float = 0.0
    jobs_by_user: Dict[str, int] = field(default_factory=dict)
    jobs_by_partition: Dict[str, int] = field(default_factory=dict)
    efficiency_by_user: Dict[str, Dict[str, float]] = field(default_factory=dict)
    low_efficiency_jobs: List[Dict[str, Any]] = field(default_factory=list)

    @property
    def cpu_waste_hours(self) -> float:
        return self.total_cpu_hours_requested - self.total_cpu_hours_used

    @property
    def overall_cpu_efficiency(self) -> float:
        if self.total_cpu_hours_requested > 0:
            return (self.total_cpu_hours_used / self.total_cpu_hours_requested) * 100
        return 0.0

    @property
    def overall_memory_efficiency(self) -> float:
        if self.total_memory_gb_hours_requested > 0:
            return (self.total_memory_gb_hours_used / self.total_memory_gb_hours_requested) * 100
        return 0.0


def _query_jobs_for_report(
    config: Config,
    start_date: str,
    end_date: str,
    user: Optional[str] = None,
    account: Optional[str] = None,
    partition: Optional[str] = None,
    all_users: bool = False,
) -> List[Dict[str, Any]]:
    """Query sacct for completed jobs within date range (excludes running jobs)."""
    slurm = config.slurm
    
    # First query: get main job info with --allocations
    cmd = [
        slurm.sacct_path,
        "--starttime", start_date,
        "--endtime", end_date,
        "--noheader", "-P",
        "--allocations",  # Only main job entries, not steps
        # Exclude running/pending jobs - only include jobs that have finished
        "--state", "COMPLETED,FAILED,CANCELLED,TIMEOUT,NODE_FAIL,OUT_OF_MEMORY,PREEMPTED,DEADLINE",
        "-o", "JobID,JobName,User,Account,State,Partition,Submit,Start,End,Elapsed,"
              "Timelimit,NNodes,NCPUs,ReqMem,AllocTRES,ExitCode"
    ]
    
    # Query all users if requested (for leaderboard) or specific user
    if all_users:
        cmd.append("--allusers")
    elif user:
        cmd.extend(["--user", user])
    if account:
        cmd.extend(["--account", account])
    if partition:
        cmd.extend(["--partition", partition])
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
        if result.returncode != 0:
            logger.error(f"sacct failed: {result.stderr}")
            return []
    except Exception as e:
        logger.error(f"Error running sacct: {e}")
        return []
    
    # Parse main job entries
    jobs = {}
    for line in result.stdout.strip().split('\n'):
        if not line:
            continue
        parts = line.split('|')
        if len(parts) < 16:
            continue
        
        job_id = parts[0]
        jobs[job_id] = {
            'job_id': job_id,
            'job_name': parts[1],
            'user': parts[2],
            'account': parts[3],
            'state': parts[4],
            'partition': parts[5],
            'submit': parts[6],
            'start': parts[7],
            'end': parts[8],
            'elapsed': parts[9],
            'timelimit': parts[10],
            'nodes': parts[11],
            'cpus': parts[12],
            'reqmem': parts[13],
            'alloctres': parts[14],
            'exitcode': parts[15],
            'maxrss': '',
            'totalcpu': '',
        }
    
    if not jobs:
        return []
    
    # Second query: get MaxRSS and TotalCPU from job steps (batch step has the real data)
    # Batch job IDs to avoid "Argument list too long" error with many jobs
    job_id_list = list(jobs.keys())
    batch_size = 500  # Process 500 jobs at a time
    
    for i in range(0, len(job_id_list), batch_size):
        batch = job_id_list[i:i + batch_size]
        job_ids = ','.join(batch)
        cmd2 = [
            slurm.sacct_path,
            "-j", job_ids,
            "--noheader", "-P",
            "-o", "JobID,MaxRSS,TotalCPU"
        ]
        
        try:
            result2 = subprocess.run(cmd2, capture_output=True, text=True, timeout=120)
            if result2.returncode == 0:
                for line in result2.stdout.strip().split('\n'):
                    if not line:
                        continue
                    parts = line.split('|')
                    if len(parts) < 3:
                        continue
                    
                    step_id = parts[0]
                    maxrss = parts[1]
                    totalcpu = parts[2]
                    
                    # Extract base job ID (handle "12345.batch" -> "12345")
                    base_job_id = step_id.split('.')[0]
                    
                    if base_job_id in jobs:
                        # Prefer .batch step data, but take any non-empty values
                        # .batch step typically has the most accurate resource usage
                        if '.batch' in step_id:
                            if maxrss:
                                jobs[base_job_id]['maxrss'] = maxrss
                            if totalcpu:
                                jobs[base_job_id]['totalcpu'] = totalcpu
                        elif not jobs[base_job_id]['maxrss'] and maxrss:
                            jobs[base_job_id]['maxrss'] = maxrss
                        elif not jobs[base_job_id]['totalcpu'] and totalcpu:
                            jobs[base_job_id]['totalcpu'] = totalcpu
        except Exception as e:
            logger.warning(f"Could not get job step details for batch {i//batch_size + 1}: {e}")
    
    return list(jobs.values())


def _calculate_report_stats(
    jobs: List[Dict[str, Any]],
    config: Config,
    low_efficiency_threshold: float = 25.0,
) -> ReportStats:
    """Calculate aggregated statistics from job list."""
    stats = ReportStats()
    job_stats_helper = JobStats(config)
    
    cpu_efficiencies = []
    mem_efficiencies = []
    time_efficiencies = []
    
    for job in jobs:
        stats.total_jobs += 1
        user = job['user']
        partition = job['partition']
        state = job['state'].split()[0]  # Handle "COMPLETED by ..." etc.
        
        # Count by state
        if 'COMPLETED' in state:
            stats.completed_jobs += 1
        elif state in ('FAILED', 'NODE_FAIL', 'TIMEOUT', 'OUT_OF_MEMORY', 'DEADLINE', 'BOOT_FAIL'):
            stats.failed_jobs += 1
        elif 'CANCELLED' in state or state == 'PREEMPTED':
            stats.cancelled_jobs += 1
        
        # Count by user/partition
        stats.jobs_by_user[user] = stats.jobs_by_user.get(user, 0) + 1
        stats.jobs_by_partition[partition] = stats.jobs_by_partition.get(partition, 0) + 1
        
        # Parse resources
        try:
            cpus = int(job['cpus']) if job['cpus'].isdigit() else 1
        except:
            cpus = 1
        
        elapsed = job_stats_helper._parse_time(job['elapsed'])
        timelimit = job_stats_helper._parse_time(job['timelimit'])
        elapsed_hours = elapsed.total_seconds() / 3600
        timelimit_hours = timelimit.total_seconds() / 3600 if timelimit.total_seconds() > 0 else elapsed_hours
        
        # CPU hours
        cpu_hours_requested = cpus * timelimit_hours
        cpu_time = job_stats_helper._parse_cpu_time(job['totalcpu'])
        cpu_hours_used = cpu_time / 3600
        
        stats.total_cpu_hours_requested += cpu_hours_requested
        stats.total_cpu_hours_used += cpu_hours_used
        
        # Memory
        reqmem_str = job['reqmem']
        nodes = int(job['nodes']) if job['nodes'].isdigit() else 1
        mem_multiplier = 1
        if reqmem_str.endswith('n'):
            mem_multiplier = nodes
            reqmem_str = reqmem_str[:-1]
        elif reqmem_str.endswith('c'):
            mem_multiplier = cpus
            reqmem_str = reqmem_str[:-1]
        
        mem_requested = job_stats_helper._parse_memory(reqmem_str) * mem_multiplier
        mem_used = job_stats_helper._parse_memory(job['maxrss'])
        
        mem_gb_hours_requested = (mem_requested / (1024**3)) * elapsed_hours
        mem_gb_hours_used = (mem_used / (1024**3)) * elapsed_hours
        
        stats.total_memory_gb_hours_requested += mem_gb_hours_requested
        stats.total_memory_gb_hours_used += mem_gb_hours_used
        
        # GPUs
        alloctres = job['alloctres']
        if 'gpu' in alloctres.lower():
            match = re.search(r'gpu[=:]?(\d+)', alloctres.lower())
            if match:
                gpu_count = int(match.group(1))
                stats.total_gpu_hours_requested += gpu_count * elapsed_hours
        
        # Calculate efficiencies
        cpu_eff = 0.0
        if cpu_hours_requested > 0:
            cpu_eff = (cpu_hours_used / cpu_hours_requested) * 100
            cpu_eff = min(100.0, max(0.0, cpu_eff))
            cpu_efficiencies.append(cpu_eff)
        
        mem_eff = 0.0
        if mem_requested > 0:
            mem_eff = (mem_used / mem_requested) * 100
            mem_eff = min(100.0, max(0.0, mem_eff))
            mem_efficiencies.append(mem_eff)
        
        time_eff = 0.0
        if timelimit_hours > 0:
            time_eff = (elapsed_hours / timelimit_hours) * 100
            time_eff = min(100.0, max(0.0, time_eff))
            time_efficiencies.append(time_eff)
        
        # Track per-user efficiency
        if user not in stats.efficiency_by_user:
            stats.efficiency_by_user[user] = {
                'cpu_sum': 0.0, 'mem_sum': 0.0, 'count': 0
            }
        stats.efficiency_by_user[user]['cpu_sum'] += cpu_eff
        stats.efficiency_by_user[user]['mem_sum'] += mem_eff
        stats.efficiency_by_user[user]['count'] += 1
        
        # Track low efficiency jobs
        if cpu_eff < low_efficiency_threshold and cpu_eff > 0:
            stats.low_efficiency_jobs.append({
                'job_id': job['job_id'],
                'user': user,
                'cpu_efficiency': cpu_eff,
                'mem_efficiency': mem_eff,
                'cpu_hours_wasted': cpu_hours_requested - cpu_hours_used,
            })
    
    # Calculate averages
    if cpu_efficiencies:
        stats.avg_cpu_efficiency = sum(cpu_efficiencies) / len(cpu_efficiencies)
    if mem_efficiencies:
        stats.avg_memory_efficiency = sum(mem_efficiencies) / len(mem_efficiencies)
    if time_efficiencies:
        stats.avg_time_efficiency = sum(time_efficiencies) / len(time_efficiencies)
    
    # Calculate per-user averages
    for user, data in stats.efficiency_by_user.items():
        if data['count'] > 0:
            data['avg_cpu'] = data['cpu_sum'] / data['count']
            data['avg_mem'] = data['mem_sum'] / data['count']
    
    # Sort low efficiency jobs by waste
    stats.low_efficiency_jobs.sort(key=lambda x: x['cpu_hours_wasted'], reverse=True)
    stats.low_efficiency_jobs = stats.low_efficiency_jobs[:10]  # Top 10
    
    return stats


def _format_report_text(stats: ReportStats, title: str) -> str:
    """Format report as plain text."""
    lines = []
    lines.append("=" * 70)
    lines.append(f"  {title}")
    lines.append("=" * 70)
    lines.append("")
    
    # Summary
    lines.append("SUMMARY")
    lines.append("-" * 40)
    lines.append(f"Total Jobs:           {stats.total_jobs}")
    lines.append(f"  Completed:          {stats.completed_jobs}")
    lines.append(f"  Failed:             {stats.failed_jobs}")
    lines.append(f"  Cancelled:          {stats.cancelled_jobs}")
    lines.append("")
    
    # Resource usage
    lines.append("RESOURCE USAGE")
    lines.append("-" * 40)
    lines.append(f"CPU Hours Requested:  {stats.total_cpu_hours_requested:,.1f}")
    lines.append(f"CPU Hours Used:       {stats.total_cpu_hours_used:,.1f}")
    lines.append(f"CPU Hours Wasted:     {stats.cpu_waste_hours:,.1f}")
    lines.append(f"GPU Hours Requested:  {stats.total_gpu_hours_requested:,.1f}")
    lines.append("")
    
    # Efficiency
    lines.append("EFFICIENCY")
    lines.append("-" * 40)
    cpu_bar = _make_bar(stats.overall_cpu_efficiency)
    mem_bar = _make_bar(stats.overall_memory_efficiency)
    avg_cpu_bar = _make_bar(stats.avg_cpu_efficiency)
    avg_mem_bar = _make_bar(stats.avg_memory_efficiency)
    lines.append(f"Overall CPU:          {cpu_bar} {stats.overall_cpu_efficiency:5.1f}%")
    lines.append(f"Overall Memory:       {mem_bar} {stats.overall_memory_efficiency:5.1f}%")
    lines.append(f"Avg Job CPU:          {avg_cpu_bar} {stats.avg_cpu_efficiency:5.1f}%")
    lines.append(f"Avg Job Memory:       {avg_mem_bar} {stats.avg_memory_efficiency:5.1f}%")
    lines.append("")
    
    # Jobs by partition
    if stats.jobs_by_partition:
        lines.append("JOBS BY PARTITION")
        lines.append("-" * 40)
        for part, count in sorted(stats.jobs_by_partition.items(), key=lambda x: -x[1]):
            lines.append(f"  {part:<20} {count:>6}")
        lines.append("")
    
    # Low efficiency jobs
    if stats.low_efficiency_jobs:
        lines.append("LOW EFFICIENCY JOBS (top 10 by CPU hours wasted)")
        lines.append("-" * 40)
        lines.append(f"  {'JobID':<12} {'User':<12} {'CPU Eff':>8} {'Wasted Hrs':>12}")
        for job in stats.low_efficiency_jobs:
            lines.append(
                f"  {job['job_id']:<12} {job['user']:<12} "
                f"{job['cpu_efficiency']:>7.1f}% {job['cpu_hours_wasted']:>11.1f}"
            )
        lines.append("")
    
    # Recommendations
    lines.append("RECOMMENDATIONS")
    lines.append("-" * 40)
    recs = []
    if stats.overall_cpu_efficiency < 50:
        recs.append("‚Ä¢ Overall CPU efficiency is low. Encourage users to request fewer CPUs or optimize code for parallelism.")
    if stats.overall_memory_efficiency < 40:
        recs.append("‚Ä¢ Overall memory efficiency is low. Users may be over-requesting memory.")
    if stats.cpu_waste_hours > 1000:
        recs.append(f"‚Ä¢ {stats.cpu_waste_hours:,.0f} CPU hours wasted this period. Consider user training on resource estimation.")
    if stats.failed_jobs > stats.total_jobs * 0.1:
        failure_pct = (stats.failed_jobs / stats.total_jobs * 100) if stats.total_jobs > 0 else 0
        recs.append(f"‚Ä¢ High failure rate ({failure_pct:.1f}%). Investigate common failure causes.")
    if stats.cancelled_jobs > stats.total_jobs * 0.15:
        cancel_pct = (stats.cancelled_jobs / stats.total_jobs * 100) if stats.total_jobs > 0 else 0
        recs.append(f"‚Ä¢ High cancellation rate ({cancel_pct:.1f}%). Users may need help with job time estimation.")
    if stats.low_efficiency_jobs:
        recs.append(f"‚Ä¢ Contact users with consistently low-efficiency jobs for targeted assistance.")
    if not recs:
        recs.append("‚Ä¢ Resource utilization looks healthy. Keep up the good work!")
    for rec in recs:
        lines.append(rec)
    lines.append("")
    
    return "\n".join(lines)


def _format_report_csv(stats: ReportStats, jobs: List[Dict[str, Any]], config: Config) -> str:
    """Format report as CSV with per-job details."""
    lines = []
    job_stats_helper = JobStats(config)
    
    # Header
    lines.append("job_id,user,account,state,partition,cpus,elapsed_hours,"
                 "cpu_hours_requested,cpu_hours_used,cpu_efficiency,"
                 "mem_requested_gb,mem_used_gb,mem_efficiency")
    
    for job in jobs:
        try:
            cpus = int(job['cpus']) if job['cpus'].isdigit() else 1
        except:
            cpus = 1
        
        elapsed = job_stats_helper._parse_time(job['elapsed'])
        timelimit = job_stats_helper._parse_time(job['timelimit'])
        elapsed_hours = elapsed.total_seconds() / 3600
        timelimit_hours = timelimit.total_seconds() / 3600 if timelimit.total_seconds() > 0 else elapsed_hours
        
        cpu_hours_requested = cpus * timelimit_hours
        cpu_time = job_stats_helper._parse_cpu_time(job['totalcpu'])
        cpu_hours_used = cpu_time / 3600
        cpu_eff = (cpu_hours_used / cpu_hours_requested * 100) if cpu_hours_requested > 0 else 0
        
        reqmem_str = job['reqmem']
        nodes = int(job['nodes']) if job['nodes'].isdigit() else 1
        mem_multiplier = 1
        if reqmem_str.endswith('n'):
            mem_multiplier = nodes
            reqmem_str = reqmem_str[:-1]
        elif reqmem_str.endswith('c'):
            mem_multiplier = cpus
            reqmem_str = reqmem_str[:-1]
        
        mem_requested = job_stats_helper._parse_memory(reqmem_str) * mem_multiplier
        mem_used = job_stats_helper._parse_memory(job['maxrss'])
        mem_eff = (mem_used / mem_requested * 100) if mem_requested > 0 else 0
        
        lines.append(
            f"{job['job_id']},{job['user']},{job['account']},{job['state']},{job['partition']},"
            f"{cpus},{elapsed_hours:.2f},{cpu_hours_requested:.2f},{cpu_hours_used:.2f},{cpu_eff:.1f},"
            f"{mem_requested/(1024**3):.2f},{mem_used/(1024**3):.2f},{mem_eff:.1f}"
        )
    
    return "\n".join(lines)


def _format_report_json(stats: ReportStats) -> str:
    """Format report as JSON."""
    data = {
        'summary': {
            'total_jobs': stats.total_jobs,
            'completed_jobs': stats.completed_jobs,
            'failed_jobs': stats.failed_jobs,
            'cancelled_jobs': stats.cancelled_jobs,
        },
        'resources': {
            'cpu_hours_requested': round(stats.total_cpu_hours_requested, 2),
            'cpu_hours_used': round(stats.total_cpu_hours_used, 2),
            'cpu_hours_wasted': round(stats.cpu_waste_hours, 2),
            'gpu_hours_requested': round(stats.total_gpu_hours_requested, 2),
            'memory_gb_hours_requested': round(stats.total_memory_gb_hours_requested, 2),
            'memory_gb_hours_used': round(stats.total_memory_gb_hours_used, 2),
        },
        'efficiency': {
            'overall_cpu_percent': round(stats.overall_cpu_efficiency, 2),
            'overall_memory_percent': round(stats.overall_memory_efficiency, 2),
            'avg_job_cpu_percent': round(stats.avg_cpu_efficiency, 2),
            'avg_job_memory_percent': round(stats.avg_memory_efficiency, 2),
        },
        'jobs_by_partition': stats.jobs_by_partition,
        'jobs_by_user': stats.jobs_by_user,
        'user_efficiency': {
            user: {
                'job_count': data['count'],
                'avg_cpu_efficiency': round(data.get('avg_cpu', 0), 2),
                'avg_memory_efficiency': round(data.get('avg_mem', 0), 2),
            }
            for user, data in stats.efficiency_by_user.items()
        },
        'low_efficiency_jobs': stats.low_efficiency_jobs,
    }
    return json.dumps(data, indent=2)


def _format_report_html(stats: ReportStats, title: str) -> str:
    """Format report as HTML."""
    html = f"""<!DOCTYPE html>
<html>
<head>
    <title>{title}</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        h1 {{ color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }}
        h2 {{ color: #555; margin-top: 30px; }}
        .card {{ background: white; border-radius: 8px; padding: 20px; margin: 15px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .stat-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }}
        .stat {{ text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px; }}
        .stat-value {{ font-size: 2em; font-weight: bold; color: #007bff; }}
        .stat-label {{ color: #666; font-size: 0.9em; margin-top: 5px; }}
        table {{ width: 100%; border-collapse: collapse; margin: 10px 0; }}
        th, td {{ padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background: #f8f9fa; font-weight: 600; }}
        tr:hover {{ background: #f5f5f5; }}
        .progress {{ background: #e9ecef; border-radius: 4px; height: 20px; overflow: hidden; }}
        .progress-bar {{ height: 100%; transition: width 0.3s; }}
        .progress-good {{ background: #28a745; }}
        .progress-warning {{ background: #ffc107; }}
        .progress-danger {{ background: #dc3545; }}
    </style>
</head>
<body>
<div class="container">
    <h1>{title}</h1>
    
    <div class="card">
        <h2>Summary</h2>
        <div class="stat-grid">
            <div class="stat">
                <div class="stat-value">{stats.total_jobs}</div>
                <div class="stat-label">Total Jobs</div>
            </div>
            <div class="stat">
                <div class="stat-value">{stats.completed_jobs}</div>
                <div class="stat-label">Completed</div>
            </div>
            <div class="stat">
                <div class="stat-value">{stats.failed_jobs}</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat">
                <div class="stat-value">{stats.cancelled_jobs}</div>
                <div class="stat-label">Cancelled</div>
            </div>
        </div>
    </div>
    
    <div class="card">
        <h2>Resource Usage</h2>
        <div class="stat-grid">
            <div class="stat">
                <div class="stat-value">{stats.total_cpu_hours_requested:,.0f}</div>
                <div class="stat-label">CPU Hours Requested</div>
            </div>
            <div class="stat">
                <div class="stat-value">{stats.total_cpu_hours_used:,.0f}</div>
                <div class="stat-label">CPU Hours Used</div>
            </div>
            <div class="stat">
                <div class="stat-value" style="color: #dc3545;">{stats.cpu_waste_hours:,.0f}</div>
                <div class="stat-label">CPU Hours Wasted</div>
            </div>
            <div class="stat">
                <div class="stat-value">{stats.total_gpu_hours_requested:,.0f}</div>
                <div class="stat-label">GPU Hours</div>
            </div>
        </div>
    </div>
    
    <div class="card">
        <h2>Efficiency</h2>
        <table>
            <tr>
                <td style="width: 200px;">Overall CPU Efficiency</td>
                <td>
                    <div class="progress">
                        <div class="progress-bar {'progress-good' if stats.overall_cpu_efficiency >= 70 else 'progress-warning' if stats.overall_cpu_efficiency >= 40 else 'progress-danger'}" style="width: {stats.overall_cpu_efficiency}%;"></div>
                    </div>
                </td>
                <td style="width: 80px; text-align: right;">{stats.overall_cpu_efficiency:.1f}%</td>
            </tr>
            <tr>
                <td>Overall Memory Efficiency</td>
                <td>
                    <div class="progress">
                        <div class="progress-bar {'progress-good' if stats.overall_memory_efficiency >= 60 else 'progress-warning' if stats.overall_memory_efficiency >= 30 else 'progress-danger'}" style="width: {stats.overall_memory_efficiency}%;"></div>
                    </div>
                </td>
                <td style="text-align: right;">{stats.overall_memory_efficiency:.1f}%</td>
            </tr>
            <tr>
                <td>Average Job CPU Efficiency</td>
                <td>
                    <div class="progress">
                        <div class="progress-bar {'progress-good' if stats.avg_cpu_efficiency >= 70 else 'progress-warning' if stats.avg_cpu_efficiency >= 40 else 'progress-danger'}" style="width: {stats.avg_cpu_efficiency}%;"></div>
                    </div>
                </td>
                <td style="text-align: right;">{stats.avg_cpu_efficiency:.1f}%</td>
            </tr>
        </table>
    </div>
"""
    
    # Low efficiency jobs
    if stats.low_efficiency_jobs:
        html += """
    <div class="card">
        <h2>Low Efficiency Jobs (Top 10)</h2>
        <table>
            <thead>
                <tr><th>Job ID</th><th>User</th><th>CPU Efficiency</th><th>CPU Hours Wasted</th></tr>
            </thead>
            <tbody>
"""
        for job in stats.low_efficiency_jobs:
            html += f"            <tr><td>{job['job_id']}</td><td>{job['user']}</td><td>{job['cpu_efficiency']:.1f}%</td><td>{job['cpu_hours_wasted']:.1f}</td></tr>\n"
        html += """            </tbody>
        </table>
    </div>
"""
    
    # Recommendations
    html += """
    <div class="card">
        <h2>Recommendations</h2>
        <ul style="line-height: 1.8; color: #333;">
"""
    recs = []
    if stats.overall_cpu_efficiency < 50:
        recs.append("Overall CPU efficiency is low. Encourage users to request fewer CPUs or optimize code for parallelism.")
    if stats.overall_memory_efficiency < 40:
        recs.append("Overall memory efficiency is low. Users may be over-requesting memory.")
    if stats.cpu_waste_hours > 1000:
        recs.append(f"{stats.cpu_waste_hours:,.0f} CPU hours wasted this period. Consider user training on resource estimation.")
    if stats.failed_jobs > stats.total_jobs * 0.1:
        failure_pct = (stats.failed_jobs / stats.total_jobs * 100) if stats.total_jobs > 0 else 0
        recs.append(f"High failure rate ({failure_pct:.1f}%). Investigate common failure causes.")
    if stats.cancelled_jobs > stats.total_jobs * 0.15:
        cancel_pct = (stats.cancelled_jobs / stats.total_jobs * 100) if stats.total_jobs > 0 else 0
        recs.append(f"High cancellation rate ({cancel_pct:.1f}%). Users may need help with job time estimation.")
    if stats.low_efficiency_jobs:
        recs.append("Contact users with consistently low-efficiency jobs for targeted assistance.")
    if not recs:
        recs.append("Resource utilization looks healthy. Keep up the good work!")
    for rec in recs:
        html += f"            <li>{rec}</li>\n"
    html += """        </ul>
    </div>
"""
    
    html += """
</div>
</body>
</html>
"""
    return html


def cmd_leaderboard(args: argparse.Namespace) -> int:
    """Generate user efficiency leaders."""
    config = load_config(args.config)
    
    # Calculate date range
    end_date = datetime.now()
    start_date = end_date - timedelta(days=args.days)
    start_str = start_date.strftime("%Y-%m-%d")
    end_str = end_date.strftime("%Y-%m-%d")
    
    if not args.quiet:
        print(f"Querying jobs from {start_str} to {end_str}...", file=sys.stderr)
    
    # Query all users' jobs for leaderboard
    jobs = _query_jobs_for_report(
        config,
        start_str,
        end_str,
        account=args.account,
        partition=args.partition,
        all_users=True,
    )
    
    if not jobs:
        print("No jobs found in the specified time period.", file=sys.stderr)
        return 1
    
    if not args.quiet:
        print(f"Found {len(jobs)} jobs. Calculating user statistics...", file=sys.stderr)
    
    # Calculate per-user statistics
    job_stats_helper = JobStats(config)
    user_stats: Dict[str, Dict[str, Any]] = {}
    
    for job in jobs:
        user = job['user']
        if user not in user_stats:
            user_stats[user] = {
                'jobs': 0,
                'completed': 0,
                'cpu_hours_requested': 0.0,
                'cpu_hours_used': 0.0,
                'cpu_cores_requested': 0,
                'cpu_cores_used': 0.0,
                'mem_requested': 0.0,
                'mem_used': 0.0,
                'cpu_eff_sum': 0.0,
                'mem_eff_sum': 0.0,
                'eff_count': 0,
            }
        
        user_stats[user]['jobs'] += 1
        state = job['state'].split()[0]
        if 'COMPLETED' in state:
            user_stats[user]['completed'] += 1
        
        # Parse resources
        try:
            cpus = int(job['cpus']) if job['cpus'].isdigit() else 1
        except:
            cpus = 1
        
        elapsed = job_stats_helper._parse_time(job['elapsed'])
        timelimit = job_stats_helper._parse_time(job['timelimit'])
        elapsed_hours = elapsed.total_seconds() / 3600
        timelimit_hours = timelimit.total_seconds() / 3600 if timelimit.total_seconds() > 0 else elapsed_hours
        
        cpu_hours_requested = cpus * timelimit_hours
        cpu_time = job_stats_helper._parse_cpu_time(job['totalcpu'])
        cpu_hours_used = cpu_time / 3600
        
        user_stats[user]['cpu_hours_requested'] += cpu_hours_requested
        user_stats[user]['cpu_hours_used'] += cpu_hours_used
        user_stats[user]['cpu_cores_requested'] += cpus
        
        # Calculate efficiency for this job
        cpu_eff = 0.0
        if cpu_hours_requested > 0:
            cpu_eff = (cpu_hours_used / cpu_hours_requested) * 100
            cpu_eff = min(100.0, max(0.0, cpu_eff))
        
        # Track effective CPU cores used (based on efficiency)
        user_stats[user]['cpu_cores_used'] += cpus * (cpu_eff / 100.0)
        
        reqmem_str = job['reqmem']
        nodes = int(job['nodes']) if job['nodes'].isdigit() else 1
        mem_multiplier = 1
        if reqmem_str.endswith('n'):
            mem_multiplier = nodes
            reqmem_str = reqmem_str[:-1]
        elif reqmem_str.endswith('c'):
            mem_multiplier = cpus
            reqmem_str = reqmem_str[:-1]
        
        mem_requested = job_stats_helper._parse_memory(reqmem_str) * mem_multiplier
        mem_used = job_stats_helper._parse_memory(job['maxrss'])
        
        user_stats[user]['mem_requested'] += mem_requested
        user_stats[user]['mem_used'] += mem_used
        
        mem_eff = 0.0
        if mem_requested > 0:
            mem_eff = (mem_used / mem_requested) * 100
            mem_eff = min(100.0, max(0.0, mem_eff))
        
        if cpu_eff > 0 or mem_eff > 0:
            user_stats[user]['cpu_eff_sum'] += cpu_eff
            user_stats[user]['mem_eff_sum'] += mem_eff
            user_stats[user]['eff_count'] += 1
    
    # Calculate averages and sort
    leaderboard = []
    for user, stats in user_stats.items():
        if stats['eff_count'] > 0:
            avg_cpu_eff = stats['cpu_eff_sum'] / stats['eff_count']
            avg_mem_eff = stats['mem_eff_sum'] / stats['eff_count']
        else:
            avg_cpu_eff = 0.0
            avg_mem_eff = 0.0
        
        # Combined score (weighted average: 50% CPU, 50% memory)
        combined_score = (avg_cpu_eff * 0.5) + (avg_mem_eff * 0.5)
        
        leaderboard.append({
            'user': user,
            'jobs': stats['jobs'],
            'completed': stats['completed'],
            'cpu_req': stats['cpu_cores_requested'],
            'cpu_use': stats['cpu_cores_used'],
            'avg_cpu_eff': avg_cpu_eff,
            'mem_req': stats['mem_requested'],
            'mem_use': stats['mem_used'],
            'avg_mem_eff': avg_mem_eff,
            'combined_score': combined_score,
            'cpu_hours_used': stats['cpu_hours_used'],
        })
    
    # Sort by combined score (descending) for efficiency ranking
    if args.sort == 'efficiency':
        leaderboard.sort(key=lambda x: x['combined_score'], reverse=True)
    elif args.sort == 'cpu':
        leaderboard.sort(key=lambda x: x['avg_cpu_eff'], reverse=True)
    elif args.sort == 'memory':
        leaderboard.sort(key=lambda x: x['avg_mem_eff'], reverse=True)
    elif args.sort == 'jobs':
        leaderboard.sort(key=lambda x: x['jobs'], reverse=True)
    
    # Apply minimum jobs filter
    if args.min_jobs > 0:
        leaderboard = [u for u in leaderboard if u['jobs'] >= args.min_jobs]
    
    # Determine what to show: top, bottom, or both
    top_list = []
    bottom_list = []
    
    if args.show_both:
        # Show both top N and bottom N
        n = args.show_both
        if len(leaderboard) > n * 2:
            top_list = leaderboard[:n]
            bottom_list = leaderboard[-n:]
        else:
            # Not enough users to split, just show all
            top_list = leaderboard
    elif args.bottom:
        # Show only bottom N (worst)
        bottom_list = leaderboard[-args.bottom:] if len(leaderboard) > args.bottom else leaderboard
    elif args.top:
        # Show only top N (best)
        top_list = leaderboard[:args.top]
    else:
        # Default: show all as top (best efficiency first)
        top_list = leaderboard
    
    # Output
    if args.format == 'json':
        output = json.dumps({
            'period': {'start': start_str, 'end': end_str, 'days': args.days},
            'leaders': top_list,
            'laggards': bottom_list,
        }, indent=2)
    elif args.format == 'html':
        output = _format_leaderboard_html(top_list, bottom_list, start_str, end_str, args.days)
    elif args.format == 'markdown':
        output = _format_leaderboard_markdown(top_list, bottom_list, start_str, end_str, args.days)
    elif args.format == 'mdhtml':
        output = _format_leaderboard_mdhtml(top_list, bottom_list, start_str, end_str, args.days)
    else:
        output = _format_leaderboard_text(top_list, bottom_list, start_str, end_str, args.days)
    
    # Write output
    if args.output:
        with open(args.output, 'w') as f:
            f.write(output)
        if not args.quiet:
            print(f"Leaderboard written to {args.output}", file=sys.stderr)
    else:
        print(output)
    
    return 0


def _format_memory_short(bytes_val: float) -> str:
    """Format memory value in human-readable short format."""
    if bytes_val <= 0:
        return "0"
    if bytes_val >= 1024**4:
        return f"{bytes_val / (1024**4):.1f}T"
    elif bytes_val >= 1024**3:
        return f"{bytes_val / (1024**3):.1f}G"
    elif bytes_val >= 1024**2:
        return f"{bytes_val / (1024**2):.1f}M"
    elif bytes_val >= 1024:
        return f"{bytes_val / 1024:.1f}K"
    else:
        return f"{bytes_val:.0f}"


def _format_leaderboard_text(leaders: List[Dict], laggards: List[Dict], start_str: str, end_str: str, days: int) -> str:
    """Format leaderboard as plain text."""
    lines = []
    
    if leaders:
        lines.append("")
        lines.append("=" * 120)
        lines.append(f"  üèÜ Efficiency Leaders | {start_str} to {end_str} ({days} days)")
        lines.append("=" * 120)
        lines.append("")
        lines.append(f"{'Rank':<6} {'User':<15} {'Jobs':>6} {'CPU Req':>9} {'CPU Use':>9} {'CPU Eff':>9} {'Mem Req':>10} {'Mem Use':>10} {'Mem Eff':>9} {'Score':>9}")
        lines.append("-" * 120)
        
        for rank, entry in enumerate(leaders, 1):
            mem_req = _format_memory_short(entry['mem_req'])
            mem_use = _format_memory_short(entry['mem_use'])
            lines.append(
                f"{rank:<6} {entry['user']:<15} {entry['jobs']:>6} "
                f"{entry['cpu_req']:>9} {entry['cpu_use']:>9.1f} {entry['avg_cpu_eff']:>8.2f}% "
                f"{mem_req:>10} {mem_use:>10} {entry['avg_mem_eff']:>8.2f}% "
                f"{entry['combined_score']:>8.2f}%"
            )
        lines.append("")
    
    if laggards:
        lines.append("")
        lines.append("=" * 120)
        lines.append(f"  ‚ö†Ô∏è  Low Efficiency Users | {start_str} to {end_str} ({days} days)")
        lines.append("=" * 120)
        lines.append("")
        lines.append(f"{'Rank':<6} {'User':<15} {'Jobs':>6} {'CPU Req':>9} {'CPU Use':>9} {'CPU Eff':>9} {'Mem Req':>10} {'Mem Use':>10} {'Mem Eff':>9} {'Score':>9}")
        lines.append("-" * 120)
        
        # Rank from bottom (worst first)
        for i, entry in enumerate(laggards):
            mem_req = _format_memory_short(entry['mem_req'])
            mem_use = _format_memory_short(entry['mem_use'])
            lines.append(
                f"{i+1:<6} {entry['user']:<15} {entry['jobs']:>6} "
                f"{entry['cpu_req']:>9} {entry['cpu_use']:>9.1f} {entry['avg_cpu_eff']:>8.2f}% "
                f"{mem_req:>10} {mem_use:>10} {entry['avg_mem_eff']:>8.2f}% "
                f"{entry['combined_score']:>8.2f}%"
            )
        lines.append("")
    
    lines.append("Score = 50% CPU efficiency + 50% memory efficiency")
    lines.append("")
    
    return "\n".join(lines)


def _format_leaderboard_markdown(leaders: List[Dict], laggards: List[Dict], start_str: str, end_str: str, days: int) -> str:
    """Format leaderboard as Markdown table."""
    generated_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    lines = []
    
    if leaders:
        lines.append(f"# üèÜ Efficiency Leaders")
        lines.append("")
        lines.append(f"**Period:** {start_str} to {end_str} ({days} days)")
        lines.append(f"**Generated:** {generated_at}")
        lines.append(f"**Score:** 50% CPU efficiency + 50% memory efficiency")
        lines.append("")
        lines.append("| Rank | User | Jobs | CPU Req | CPU Use | CPU Eff | Mem Req | Mem Use | Mem Eff | Score |")
        lines.append("|------|------|-----:|--------:|--------:|--------:|--------:|--------:|--------:|------:|")
        
        for rank, entry in enumerate(leaders, 1):
            mem_req = _format_memory_short(entry['mem_req'])
            mem_use = _format_memory_short(entry['mem_use'])
            
            if rank == 1:
                rank_str = "ü•á 1"
            elif rank == 2:
                rank_str = "ü•à 2"
            elif rank == 3:
                rank_str = "ü•â 3"
            else:
                rank_str = str(rank)
            
            lines.append(
                f"| {rank_str} | {entry['user']} | {entry['jobs']} | "
                f"{entry['cpu_req']} | {entry['cpu_use']:.1f} | {entry['avg_cpu_eff']:.2f}% | "
                f"{mem_req} | {mem_use} | {entry['avg_mem_eff']:.2f}% | "
                f"{entry['combined_score']:.2f}% |"
            )
        lines.append("")
    
    if laggards:
        lines.append(f"# ‚ö†Ô∏è Low Efficiency Users")
        lines.append("")
        if not leaders:
            lines.append(f"**Period:** {start_str} to {end_str} ({days} days)")
            lines.append(f"**Generated:** {generated_at}")
            lines.append(f"**Score:** 50% CPU efficiency + 50% memory efficiency")
            lines.append("")
        lines.append("| Rank | User | Jobs | CPU Req | CPU Use | CPU Eff | Mem Req | Mem Use | Mem Eff | Score |")
        lines.append("|------|------|-----:|--------:|--------:|--------:|--------:|--------:|--------:|------:|")
        
        for rank, entry in enumerate(laggards, 1):
            mem_req = _format_memory_short(entry['mem_req'])
            mem_use = _format_memory_short(entry['mem_use'])
            lines.append(
                f"| {rank} | {entry['user']} | {entry['jobs']} | "
                f"{entry['cpu_req']} | {entry['cpu_use']:.1f} | {entry['avg_cpu_eff']:.2f}% | "
                f"{mem_req} | {mem_use} | {entry['avg_mem_eff']:.2f}% | "
                f"{entry['combined_score']:.2f}% |"
            )
        lines.append("")
    
    return "\n".join(lines)


def _format_leaderboard_mdhtml(leaders: List[Dict], laggards: List[Dict], start_str: str, end_str: str, days: int) -> str:
    """Format leaderboard as Markdown with embedded interactive HTML."""
    generated_at = datetime.now().strftime("%y-%m-%d %H:%M:%S")
    days_str = "1 day" if days == 1 else f"{days} days"
    
    md = ""
    
    # CSS styles (only once at the top)
    md += """<style>
.lb-controls { background: #f8f9fa; padding: 6px 10px; border-radius: 5px; margin-bottom: 8px; font-size: 0.85em; white-space: nowrap; display: inline-block; }
.lb-controls label { margin-right: 12px; cursor: pointer; }
.lb-controls input { margin-right: 3px; cursor: pointer; }
.lb-table { border-collapse: collapse; }
.lb-table th { background: #005f85; color: white; padding: 8px 12px; text-align: left; cursor: pointer; white-space: nowrap; }
.lb-table th:hover { background: #004a68; }
.lb-table td { padding: 8px 12px; border-bottom: 1px solid #ddd; white-space: nowrap; }
.lb-table tr:hover { background: #f5f5f5; }
.lb-table.laggards th { background: #c0392b; }
.lb-table.laggards th:hover { background: #a93226; }
.lb-hidden { display: none; }
.lb-good { color: #28a745; }
.lb-warn { color: #ffc107; }
.lb-bad { color: #dc3545; }
.lb-score { font-weight: bold; color: #007bff; }
</style>

"""
    
    # Leaders section
    if leaders:
        md += f"""## üèÜ Efficiency Leaders

<details>
<summary>Details</summary>
<p><strong>Period:</strong> {days_str} | <strong>Generated:</strong> {generated_at}</p>
<p style="font-size: 0.85em; color: #555; margin: 8px 0;">This leaderboard ranks users by how efficiently they use allocated cluster resources. <strong>CPU Eff</strong> = CPU time used / CPU time requested. <strong>Mem Eff</strong> = peak memory used / memory requested. <strong>Score</strong> = average of CPU and Memory efficiency (50/50 weighting). Higher scores indicate better resource utilization.</p>
</details>

<table class="lb-table" id="lb-table-leaders">
<thead>
<tr>
<th>Rank</th>
<th>User</th>
<th>CPU Eff</th>
<th>Mem Eff</th>
<th>Score</th>
</tr>
</thead>
<tbody>
"""
        
        for rank, entry in enumerate(leaders, 1):
            # Medal emoji for top 3
            if rank == 1:
                rank_str = "ü•á 1"
            elif rank == 2:
                rank_str = "ü•à 2"
            elif rank == 3:
                rank_str = "ü•â 3"
            else:
                rank_str = str(rank)
            
            cpu_class = 'lb-good' if entry['avg_cpu_eff'] >= 70 else 'lb-warn' if entry['avg_cpu_eff'] >= 40 else 'lb-bad'
            mem_class = 'lb-good' if entry['avg_mem_eff'] >= 60 else 'lb-warn' if entry['avg_mem_eff'] >= 30 else 'lb-bad'
            
            md += f"""<tr>
<td>{rank_str}</td>
<td>{entry['user']}</td>
<td class="{cpu_class}">{entry['avg_cpu_eff']:.2f}%</td>
<td class="{mem_class}">{entry['avg_mem_eff']:.2f}%</td>
<td class="lb-score">{entry['combined_score']:.2f}%</td>
</tr>
"""
        
        md += """</tbody>
</table>

"""
    
    # Laggards section
    if laggards:
        md += f"""## ‚ö†Ô∏è Low Efficiency Users

"""
        if not leaders:
            md += f"""<details>
<summary>Details</summary>
<p><strong>Period:</strong> {days_str} | <strong>Generated:</strong> {generated_at}</p>
<p style="font-size: 0.85em; color: #555; margin: 8px 0;">Users with low resource efficiency. Consider reaching out to offer optimization assistance.</p>
</details>

"""
        
        md += """<table class="lb-table laggards" id="lb-table-laggards">
<thead>
<tr>
<th>Rank</th>
<th>User</th>
<th>CPU Eff</th>
<th>Mem Eff</th>
<th>Score</th>
</tr>
</thead>
<tbody>
"""
        
        for rank, entry in enumerate(laggards, 1):
            cpu_class = 'lb-good' if entry['avg_cpu_eff'] >= 70 else 'lb-warn' if entry['avg_cpu_eff'] >= 40 else 'lb-bad'
            mem_class = 'lb-good' if entry['avg_mem_eff'] >= 60 else 'lb-warn' if entry['avg_mem_eff'] >= 30 else 'lb-bad'
            
            md += f"""<tr>
<td>{rank}</td>
<td>{entry['user']}</td>
<td class="{cpu_class}">{entry['avg_cpu_eff']:.2f}%</td>
<td class="{mem_class}">{entry['avg_mem_eff']:.2f}%</td>
<td class="lb-score">{entry['combined_score']:.2f}%</td>
</tr>
"""
        
        md += """</tbody>
</table>
"""
    
    return md


def _format_leaderboard_html(leaders: List[Dict], laggards: List[Dict], start_str: str, end_str: str, days: int) -> str:
    """Format leaderboard as HTML with sortable columns."""
    generated_at = datetime.now().strftime("%y-%m-%d %H:%M:%S")
    days_str = "1 day" if days == 1 else f"{days} days"
    html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Efficiency Leaderboard</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 20px; background: #f5f5f5; }}
        h3 {{ color: #333; border-bottom: 2px solid #005f85; padding-bottom: 10px; white-space: nowrap; margin-bottom: 8px; display: inline-block; }}
        h3.laggards {{ border-bottom-color: #c0392b; }}
        .subtitle {{ color: #666; margin-bottom: 10px; font-size: 0.9em; white-space: nowrap; }}
        table {{ border-collapse: collapse; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border-radius: 8px; overflow: hidden; margin-bottom: 20px; }}
        th {{ background: #005f85; color: white; padding: 10px 12px; text-align: left; font-weight: 600; cursor: pointer; user-select: none; position: relative; white-space: nowrap; }}
        th:hover {{ background: #004a68; }}
        table.laggards th {{ background: #c0392b; }}
        table.laggards th:hover {{ background: #a93226; }}
        th.sort-asc::after {{ content: ' \25B2'; font-size: 0.8em; }}
        th.sort-desc::after {{ content: ' \25BC'; font-size: 0.8em; }}
        td {{ padding: 8px 12px; border-bottom: 1px solid #eee; white-space: nowrap; }}
        tr:hover {{ background: #f8f9fa; }}
        tr:last-child td {{ border-bottom: none; }}
        .rank {{ font-weight: bold; font-size: 1.1em; white-space: nowrap; }}
        .rank-1 {{ color: #FFD700; }}
        .rank-2 {{ color: #C0C0C0; }}
        .rank-3 {{ color: #CD7F32; }}
        .medal {{ font-size: 1.2em; margin-right: 5px; }}
        .score {{ font-weight: bold; color: #007bff; }}
        .efficiency-good {{ color: #28a745; }}
        .efficiency-warning {{ color: #ffc107; }}
        .efficiency-danger {{ color: #dc3545; }}
        .footer {{ margin-top: 20px; color: #666; font-size: 0.9em; }}
        .sort-hint {{ font-size: 0.85em; color: #888; margin-bottom: 10px; }}
        details {{ margin-bottom: 10px; }}
        summary {{ cursor: pointer; font-size: 0.85em; color: #666; padding: 4px 0; }}
        summary:hover {{ color: #333; }}
        .details-content {{ padding-top: 8px; }}
    </style>
</head>
<body>
"""
    
    # Leaders section
    if leaders:
        html += f"""    <h3>\\U0001F3C6 Efficiency Leaders</h3>
    
    <details>
        <summary>Details</summary>
        <div class="details-content">
            <p style="margin: 0 0 8px 0; font-size: 0.85em;"><strong>Period:</strong> {days_str} | <strong>Generated:</strong> {generated_at}</p>
            <p style="font-size: 0.85em; color: #555; margin: 0 0 10px 0; max-width: 600px;">This leaderboard ranks users by how efficiently they use allocated cluster resources. <strong>CPU Eff</strong> = CPU time used / CPU time requested. <strong>Mem Eff</strong> = peak memory used / memory requested. <strong>Score</strong> = average of CPU and Memory efficiency (50/50 weighting). Higher scores indicate better resource utilization.</p>
            <p class="sort-hint">Click column headers to sort</p>
        </div>
    </details>
    
    <table id="leaderboard-leaders" class="sortable-table">
        <thead>
            <tr>
                <th data-sort="rank" data-type="number">Rank</th>
                <th data-sort="user" data-type="string">User</th>
                <th data-sort="cpu" data-type="number">CPU Eff</th>
                <th data-sort="mem" data-type="number">Mem Eff</th>
                <th data-sort="score" data-type="number">Score</th>
            </tr>
        </thead>
        <tbody>
"""
        
        for rank, entry in enumerate(leaders, 1):
            # Medal and rank styling
            if rank == 1:
                medal = '<span class="medal">\U0001F947</span>'
                rank_class = 'rank-1'
            elif rank == 2:
                medal = '<span class="medal">\U0001F948</span>'
                rank_class = 'rank-2'
            elif rank == 3:
                medal = '<span class="medal">\U0001F949</span>'
                rank_class = 'rank-3'
            else:
                medal = '<span class="medal" style="visibility:hidden;">\U0001F947</span>'
                rank_class = ''
            
            # Efficiency color coding
            cpu_class = 'efficiency-good' if entry['avg_cpu_eff'] >= 70 else 'efficiency-warning' if entry['avg_cpu_eff'] >= 40 else 'efficiency-danger'
            mem_class = 'efficiency-good' if entry['avg_mem_eff'] >= 60 else 'efficiency-warning' if entry['avg_mem_eff'] >= 30 else 'efficiency-danger'
            
            html += f"""            <tr data-rank="{rank}" data-user="{entry['user']}" data-cpu="{entry['avg_cpu_eff']:.4f}" data-mem="{entry['avg_mem_eff']:.4f}" data-score="{entry['combined_score']:.4f}">
                <td class="rank {rank_class}">{medal}{rank}</td>
                <td>{entry['user']}</td>
                <td class="{cpu_class}">{entry['avg_cpu_eff']:.2f}%</td>
                <td class="{mem_class}">{entry['avg_mem_eff']:.2f}%</td>
                <td class="score">{entry['combined_score']:.2f}%</td>
            </tr>
"""
        
        html += """        </tbody>
    </table>

"""
    
    # Laggards section
    if laggards:
        html += f"""    <h3 class="laggards">\\u26A0\\uFE0F Low Efficiency Users</h3>
"""
        if not leaders:
            html += f"""    
    <details>
        <summary>Details</summary>
        <div class="details-content">
            <p style="margin: 0 0 8px 0; font-size: 0.85em;"><strong>Period:</strong> {days_str} | <strong>Generated:</strong> {generated_at}</p>
            <p style="font-size: 0.85em; color: #555; margin: 0 0 10px 0; max-width: 600px;">Users with low resource efficiency. Consider reaching out to offer optimization assistance.</p>
            <p class="sort-hint">Click column headers to sort</p>
        </div>
    </details>
"""
        
        html += """    
    <table id="leaderboard-laggards" class="sortable-table laggards">
        <thead>
            <tr>
                <th data-sort="rank" data-type="number">Rank</th>
                <th data-sort="user" data-type="string">User</th>
                <th data-sort="cpu" data-type="number">CPU Eff</th>
                <th data-sort="mem" data-type="number">Mem Eff</th>
                <th data-sort="score" data-type="number">Score</th>
            </tr>
        </thead>
        <tbody>
"""
        
        for rank, entry in enumerate(laggards, 1):
            # Efficiency color coding
            cpu_class = 'efficiency-good' if entry['avg_cpu_eff'] >= 70 else 'efficiency-warning' if entry['avg_cpu_eff'] >= 40 else 'efficiency-danger'
            mem_class = 'efficiency-good' if entry['avg_mem_eff'] >= 60 else 'efficiency-warning' if entry['avg_mem_eff'] >= 30 else 'efficiency-danger'
            
            html += f"""            <tr data-rank="{rank}" data-user="{entry['user']}" data-cpu="{entry['avg_cpu_eff']:.4f}" data-mem="{entry['avg_mem_eff']:.4f}" data-score="{entry['combined_score']:.4f}">
                <td class="rank">{rank}</td>
                <td>{entry['user']}</td>
                <td class="{cpu_class}">{entry['avg_cpu_eff']:.2f}%</td>
                <td class="{mem_class}">{entry['avg_mem_eff']:.2f}%</td>
                <td class="score">{entry['combined_score']:.2f}%</td>
            </tr>
"""
        
        html += """        </tbody>
    </table>
"""
    
    html += """
<script>
// Sortable table functionality
document.addEventListener('DOMContentLoaded', function() {
    const tables = document.querySelectorAll('.sortable-table');
    
    tables.forEach(table => {
        const headers = table.querySelectorAll('th');
        let currentSort = { column: null, direction: 'asc' };
        
        headers.forEach(header => {
            header.addEventListener('click', function() {
                const sortKey = this.dataset.sort;
                const sortType = this.dataset.type;
                
                // Toggle direction if same column
                if (currentSort.column === sortKey) {
                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort.column = sortKey;
                    currentSort.direction = 'asc';
                }
                
                // Update header styling
                headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
                this.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                
                // Sort rows
                const tbody = table.querySelector('tbody');
                const rows = Array.from(tbody.querySelectorAll('tr'));
                
                rows.sort((a, b) => {
                    let aVal = a.dataset[sortKey];
                    let bVal = b.dataset[sortKey];
                    
                    if (sortType === 'number') {
                        aVal = parseFloat(aVal);
                        bVal = parseFloat(bVal);
                    } else {
                        aVal = aVal.toLowerCase();
                        bVal = bVal.toLowerCase();
                    }
                    
                    if (aVal < bVal) return currentSort.direction === 'asc' ? -1 : 1;
                    if (aVal > bVal) return currentSort.direction === 'asc' ? 1 : -1;
                    return 0;
                });
                
                // Re-append sorted rows
                rows.forEach(row => tbody.appendChild(row));
            });
        });
    });
});
</script>
</body>
</html>
"""
    return html


# =============================================================================
# Sitrep Command - Cluster Status Overview
# =============================================================================

def cmd_sitrep(args: argparse.Namespace) -> int:
    """Generate high-level cluster status report using sinfo and squeue."""
    config = load_config(args.config)
    job_stats_helper = JobStats(config)
    
    if not args.quiet:
        print("Gathering cluster status...", file=sys.stderr)
    
    # Get node status from sinfo
    node_info = _get_node_info(config, job_stats_helper)
    
    # Get total cluster resources
    cluster_resources = _get_cluster_resources(config, job_stats_helper)
    
    # Get per-node details
    node_details = _get_node_details(config, job_stats_helper)
    
    # Get job queue status from squeue
    queue_info = _get_queue_info(config, job_stats_helper)
    
    # Get top users
    top_users = _get_top_users(queue_info.get('jobs', []))
    
    # Calculate resource percentages
    in_use_cpus = queue_info.get('total_cpus', 0)
    in_use_memory = queue_info.get('total_memory', 0)
    in_use_gpus = queue_info.get('total_gpus', 0)
    total_cpus = cluster_resources.get('total_cpus', 0)
    total_memory = cluster_resources.get('total_memory', 0)
    total_gpus = cluster_resources.get('total_gpus', 0)
    
    cpu_pct = (in_use_cpus / total_cpus * 100) if total_cpus > 0 else 0
    mem_pct = (in_use_memory / total_memory * 100) if total_memory > 0 else 0
    gpu_pct = (in_use_gpus / total_gpus * 100) if total_gpus > 0 else 0
    
    # Build sitrep data
    sitrep_data = {
        'timestamp': datetime.now().isoformat(),
        'nodes': node_info,
        'jobs': {
            'running': queue_info.get('running', 0),
            'pending': queue_info.get('pending', 0),
            'total': queue_info.get('total', 0),
        },
        'resources_requested': {
            'cpus': in_use_cpus,
            'memory_bytes': in_use_memory,
            'memory_human': _format_memory_short(in_use_memory),
            'gpus': in_use_gpus,
        },
        'resources_total': {
            'cpus': total_cpus,
            'memory_bytes': total_memory,
            'memory_human': _format_memory_short(total_memory),
            'gpus': total_gpus,
        },
        'resources_pct': {
            'cpus': cpu_pct,
            'memory': mem_pct,
            'gpus': gpu_pct,
        },
        'top_users': top_users,
        'partitions': queue_info.get('partitions', {}),
        'node_details': node_details,
    }
    
    # Format output
    if args.format == 'json':
        output = json.dumps(sitrep_data, indent=2)
    elif args.format == 'html':
        output = _format_sitrep_html(sitrep_data)
    elif args.format == 'markdown':
        output = _format_sitrep_markdown(sitrep_data)
    elif args.format == 'mdhtml':
        output = _format_sitrep_mdhtml(sitrep_data)
    else:
        output = _format_sitrep_text(sitrep_data)
    
    # Write output
    if args.output:
        with open(args.output, 'w') as f:
            f.write(output)
        if not args.quiet:
            print(f"Sitrep written to {args.output}", file=sys.stderr)
    else:
        print(output)
    
    return 0


def _get_node_info(config: Config, job_stats: JobStats) -> Dict[str, Any]:
    """Get node status information from sinfo."""
    node_info = {
        'total': 0,
        'allocated': 0,
        'idle': 0,
        'down': 0,
        'drain': 0,
        'mixed': 0,
        'reserved': 0,
        'other': 0,
        'by_partition': {},
    }
    
    # Run sinfo to get node states
    # Format: PARTITION|AVAIL|NODES|STATE|NODELIST
    cmd = [
        config.slurm.sinfo_path,
        '--noheader',
        '-o', '%P|%a|%D|%T|%N'
    ]
    
    stdout, stderr, rc = job_stats._run_command(cmd)
    if rc != 0:
        logger.warning(f"sinfo command failed: {stderr}")
        return node_info
    
    for line in stdout.strip().split('\n'):
        if not line.strip():
            continue
        parts = line.split('|')
        if len(parts) < 4:
            continue
        
        partition = parts[0].rstrip('*')  # Remove default partition marker
        avail = parts[1]
        try:
            nodes = int(parts[2])
        except ValueError:
            nodes = 0
        state = parts[3].lower()
        
        # Track by partition
        if partition not in node_info['by_partition']:
            node_info['by_partition'][partition] = {
                'total': 0, 'allocated': 0, 'idle': 0, 'down': 0,
                'drain': 0, 'mixed': 0, 'reserved': 0, 'other': 0
            }
        
        node_info['total'] += nodes
        node_info['by_partition'][partition]['total'] += nodes
        
        # Categorize state
        if 'alloc' in state:
            node_info['allocated'] += nodes
            node_info['by_partition'][partition]['allocated'] += nodes
        elif 'idle' in state:
            node_info['idle'] += nodes
            node_info['by_partition'][partition]['idle'] += nodes
        elif 'down' in state:
            node_info['down'] += nodes
            node_info['by_partition'][partition]['down'] += nodes
        elif 'drain' in state:
            node_info['drain'] += nodes
            node_info['by_partition'][partition]['drain'] += nodes
        elif 'mix' in state:
            node_info['mixed'] += nodes
            node_info['by_partition'][partition]['mixed'] += nodes
        elif 'resv' in state:
            node_info['reserved'] += nodes
            node_info['by_partition'][partition]['reserved'] += nodes
        else:
            node_info['other'] += nodes
            node_info['by_partition'][partition]['other'] += nodes
    
    return node_info


def _get_cluster_resources(config: Config, job_stats: JobStats) -> Dict[str, Any]:
    """Get total cluster resources from sinfo."""
    resources = {
        'total_cpus': 0,
        'total_memory': 0,
        'total_gpus': 0,
    }
    
    # Run sinfo to get per-node resources
    # Format: NODELIST|CPUS|MEMORY|GRES|STATE
    cmd = [
        config.slurm.sinfo_path,
        '--noheader',
        '-N',  # Node-centric view
        '-o', '%N|%c|%m|%G|%T'
    ]
    
    stdout, stderr, rc = job_stats._run_command(cmd)
    if rc != 0:
        logger.warning(f"sinfo command failed for resources: {stderr}")
        return resources
    
    seen_nodes = set()  # Avoid counting nodes multiple times (they appear per partition)
    
    for line in stdout.strip().split('\n'):
        if not line.strip():
            continue
        parts = line.split('|')
        if len(parts) < 5:
            continue
        
        nodename = parts[0]
        if nodename in seen_nodes:
            continue
        seen_nodes.add(nodename)
        
        # Skip down/drain nodes for capacity calculation
        state = parts[4].lower()
        if 'down' in state or 'drain' in state:
            continue
        
        try:
            cpus = int(parts[1])
        except ValueError:
            cpus = 0
        
        # Memory is in MB from sinfo
        try:
            memory_mb = int(parts[2])
            memory_bytes = memory_mb * 1024 * 1024
        except ValueError:
            memory_bytes = 0
        
        # Parse GPUs from GRES
        gpus = 0
        gres_str = parts[3]
        if gres_str and gres_str != '(null)':
            gpu_match = re.search(r'gpu[^:]*:(\d+)', gres_str.lower())
            if gpu_match:
                gpus = int(gpu_match.group(1))
        
        resources['total_cpus'] += cpus
        resources['total_memory'] += memory_bytes
        resources['total_gpus'] += gpus
    
    return resources


def _get_node_details(config: Config, job_stats: JobStats) -> List[Dict[str, Any]]:
    """Get per-node resource availability from sinfo."""
    nodes = []
    
    # Run sinfo to get per-node resources with allocation info
    # Format: NODELIST|CPUS|CPUS_ALLOC|MEMORY|FREE_MEM|GRES|GRES_USED|STATE
    cmd = [
        config.slurm.sinfo_path,
        '--noheader',
        '-N',  # Node-centric view
        '-o', '%N|%c|%C|%m|%e|%G|%b|%T'
    ]
    
    stdout, stderr, rc = job_stats._run_command(cmd)
    if rc != 0:
        logger.warning(f"sinfo command failed for node details: {stderr}")
        return nodes
    
    seen_nodes = set()  # Avoid counting nodes multiple times (they appear per partition)
    
    for line in stdout.strip().split('\n'):
        if not line.strip():
            continue
        parts = line.split('|')
        if len(parts) < 8:
            continue
        
        nodename = parts[0]
        if nodename in seen_nodes:
            continue
        seen_nodes.add(nodename)
        
        state = parts[7].lower()
        
        # Parse total CPUs
        try:
            total_cpus = int(parts[1])
        except ValueError:
            total_cpus = 0
        
        # Parse CPU allocation info: A/I/O/T format (Allocated/Idle/Other/Total)
        cpus_alloc = 0
        cpus_avail = total_cpus
        cpu_info = parts[2]
        if '/' in cpu_info:
            cpu_parts = cpu_info.split('/')
            if len(cpu_parts) >= 2:
                try:
                    cpus_alloc = int(cpu_parts[0])
                    cpus_avail = int(cpu_parts[1]) if len(cpu_parts) > 1 else total_cpus - cpus_alloc
                except ValueError:
                    cpus_avail = total_cpus
        
        # Parse total memory (in MB from sinfo)
        try:
            total_memory_mb = int(parts[3])
        except ValueError:
            total_memory_mb = 0
        
        # Parse free memory (in MB from sinfo)
        try:
            free_memory_mb = int(parts[4]) if parts[4] and parts[4] != 'N/A' else total_memory_mb
        except ValueError:
            free_memory_mb = total_memory_mb
        
        # Parse total GPUs from GRES (format: gpu:type:count or gpu:count)
        total_gpus = 0
        gres_str = parts[5]
        if gres_str and gres_str != '(null)':
            # Match patterns like gpu:a30:1, gpu:2g.12gb:2, or gpu:1
            # Look for gpu followed by optional type, then :count
            for gpu_match in re.finditer(r'gpu(?::[^:,()]+)?:(\d+)', gres_str.lower()):
                total_gpus += int(gpu_match.group(1))
        
        # Parse used GPUs from GRES_USED
        used_gpus = 0
        gres_used_str = parts[6]
        if gres_used_str and gres_used_str != '(null)':
            # Same pattern for used GPUs
            for gpu_used_match in re.finditer(r'gpu(?::[^:,()]+)?:(\d+)', gres_used_str.lower()):
                used_gpus += int(gpu_used_match.group(1))
        
        avail_gpus = max(0, total_gpus - used_gpus)
        
        nodes.append({
            'name': nodename,
            'state': state,
            'cpus_total': total_cpus,
            'cpus_avail': cpus_avail,
            'mem_total_mb': total_memory_mb,
            'mem_avail_mb': free_memory_mb,
            'gpus_total': total_gpus,
            'gpus_avail': avail_gpus,
        })
    
    # Sort by node name
    nodes.sort(key=lambda x: x['name'])
    
    return nodes


def _get_queue_info(config: Config, job_stats: JobStats) -> Dict[str, Any]:
    """Get job queue information from squeue."""
    queue_info = {
        'running': 0,
        'pending': 0,
        'total': 0,
        'total_cpus': 0,
        'total_memory': 0,
        'total_gpus': 0,
        'jobs': [],
        'partitions': {},
    }
    
    # Run squeue to get all jobs
    # Format: JOBID|USER|STATE|PARTITION|CPUS|MIN_MEMORY|GRES|NODES
    cmd = [
        config.slurm.squeue_path,
        '--noheader',
        '-o', '%i|%u|%T|%P|%C|%m|%b|%D'
    ]
    
    stdout, stderr, rc = job_stats._run_command(cmd)
    if rc != 0:
        logger.warning(f"squeue command failed: {stderr}")
        return queue_info
    
    for line in stdout.strip().split('\n'):
        if not line.strip():
            continue
        parts = line.split('|')
        if len(parts) < 8:
            continue
        
        job_id = parts[0]
        user = parts[1]
        state = parts[2].upper()
        partition = parts[3]
        try:
            cpus = int(parts[4])
        except ValueError:
            cpus = 0
        mem_str = parts[5]
        gres_str = parts[6]
        try:
            nodes = int(parts[7])
        except ValueError:
            nodes = 1
        
        # Parse memory
        mem_bytes = job_stats._parse_memory(mem_str.rstrip('n').rstrip('c'))
        # If memory is per-node or per-cpu, multiply appropriately
        if mem_str.endswith('n'):
            mem_bytes *= nodes
        elif mem_str.endswith('c'):
            mem_bytes *= cpus
        
        # Parse GPUs from GRES
        gpus = 0
        if gres_str and gres_str != '(null)':
            gpu_match = re.search(r'gpu[^:]*:(\d+)', gres_str.lower())
            if gpu_match:
                gpus = int(gpu_match.group(1))
        
        job_entry = {
            'job_id': job_id,
            'user': user,
            'state': state,
            'partition': partition,
            'cpus': cpus,
            'memory': mem_bytes,
            'gpus': gpus,
            'nodes': nodes,
        }
        queue_info['jobs'].append(job_entry)
        
        # Track partition stats
        if partition not in queue_info['partitions']:
            queue_info['partitions'][partition] = {
                'running': 0, 'pending': 0, 'cpus': 0, 'memory': 0, 'gpus': 0
            }
        
        queue_info['total'] += 1
        
        if state == 'RUNNING':
            queue_info['running'] += 1
            queue_info['partitions'][partition]['running'] += 1
            queue_info['total_cpus'] += cpus
            queue_info['total_memory'] += mem_bytes
            queue_info['total_gpus'] += gpus
            queue_info['partitions'][partition]['cpus'] += cpus
            queue_info['partitions'][partition]['memory'] += mem_bytes
            queue_info['partitions'][partition]['gpus'] += gpus
        elif state == 'PENDING':
            queue_info['pending'] += 1
            queue_info['partitions'][partition]['pending'] += 1
    
    return queue_info


def _get_top_users(jobs: List[Dict]) -> List[Dict[str, Any]]:
    """Get top 3 users by running job count."""
    user_stats: Dict[str, Dict[str, Any]] = {}
    
    for job in jobs:
        if job['state'] != 'RUNNING':
            continue
        
        user = job['user']
        if user not in user_stats:
            user_stats[user] = {
                'user': user,
                'running_jobs': 0,
                'cpus': 0,
                'memory': 0,
                'gpus': 0,
            }
        
        user_stats[user]['running_jobs'] += 1
        user_stats[user]['cpus'] += job['cpus']
        user_stats[user]['memory'] += job['memory']
        user_stats[user]['gpus'] += job['gpus']
    
    # Sort by running jobs, then by CPUs
    sorted_users = sorted(
        user_stats.values(),
        key=lambda x: (x['running_jobs'], x['cpus']),
        reverse=True
    )
    
    return sorted_users[:3]


def _format_sitrep_text(data: Dict[str, Any]) -> str:
    """Format sitrep as plain text."""
    lines = []
    timestamp = datetime.fromisoformat(data['timestamp']).strftime("%Y-%m-%d %H:%M:%S")
    
    lines.append("")
    lines.append("=" * 70)
    lines.append(f"  SLURM CLUSTER SITREP | {timestamp}")
    lines.append("=" * 70)
    
    # Node status
    nodes = data['nodes']
    lines.append("")
    lines.append("NODE STATUS")
    lines.append("-" * 70)
    lines.append(f"  Total Nodes:    {nodes['total']:>6}")
    lines.append(f"  Allocated:      {nodes['allocated']:>6}  (fully allocated)")
    lines.append(f"  Mixed:          {nodes['mixed']:>6}  (partially allocated)")
    lines.append(f"  Idle:           {nodes['idle']:>6}  (available)")
    lines.append(f"  Drain:          {nodes['drain']:>6}  (draining/drained)")
    lines.append(f"  Down:           {nodes['down']:>6}  (unavailable)")
    if nodes['reserved'] > 0:
        lines.append(f"  Reserved:       {nodes['reserved']:>6}")
    if nodes['other'] > 0:
        lines.append(f"  Other:          {nodes['other']:>6}")
    
    # Job status
    jobs = data['jobs']
    lines.append("")
    lines.append("JOB QUEUE")
    lines.append("-" * 70)
    lines.append(f"  Running Jobs:   {jobs['running']:>6}")
    lines.append(f"  Pending Jobs:   {jobs['pending']:>6}")
    lines.append(f"  Total Jobs:     {jobs['total']:>6}")
    
    # Resources requested (running jobs)
    res = data['resources_requested']
    lines.append("")
    lines.append("RESOURCES IN USE (Running Jobs)")
    lines.append("-" * 70)
    lines.append(f"  CPUs:           {res['cpus']:>6}")
    lines.append(f"  Memory:         {res['memory_human']:>6}")
    lines.append(f"  GPUs:           {res['gpus']:>6}")
    
    # Top users
    top_users = data['top_users']
    if top_users:
        lines.append("")
        lines.append("TOP 3 USERS (by running jobs)")
        lines.append("-" * 70)
        lines.append(f"  {'User':<15} {'Jobs':>8} {'CPUs':>8} {'Memory':>10} {'GPUs':>6}")
        lines.append("  " + "-" * 49)
        for user in top_users:
            mem = _format_memory_short(user['memory'])
            lines.append(f"  {user['user']:<15} {user['running_jobs']:>8} {user['cpus']:>8} {mem:>10} {user['gpus']:>6}")
    
    # Partition breakdown
    partitions = data.get('partitions', {})
    if partitions:
        lines.append("")
        lines.append("PARTITION BREAKDOWN")
        lines.append("-" * 70)
        lines.append(f"  {'Partition':<20} {'Running':>8} {'Pending':>8} {'CPUs':>8} {'Memory':>10} {'GPUs':>6}")
        lines.append("  " + "-" * 62)
        for part_name, part_data in sorted(partitions.items()):
            mem = _format_memory_short(part_data['memory'])
            lines.append(
                f"  {part_name:<20} {part_data['running']:>8} {part_data['pending']:>8} "
                f"{part_data['cpus']:>8} {mem:>10} {part_data['gpus']:>6}"
            )
    
    lines.append("")
    lines.append("=" * 70)
    lines.append("")
    
    return "\n".join(lines)


def _format_sitrep_html(data: Dict[str, Any]) -> str:
    """Format sitrep as HTML."""
    timestamp = datetime.fromisoformat(data['timestamp']).strftime("%Y-%m-%d %H:%M:%S")
    nodes = data['nodes']
    jobs = data['jobs']
    res = data['resources_requested']
    top_users = data['top_users']
    partitions = data.get('partitions', {})
    
    html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slurm Cluster Sitrep</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }}
        h1 {{
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }}
        .timestamp {{
            color: #666;
            font-size: 0.9em;
            margin-bottom: 20px;
        }}
        .section {{
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        .section h2 {{
            margin-top: 0;
            color: #2c3e50;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }}
        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }}
        .stat-box {{
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }}
        .stat-value {{
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
        }}
        .stat-label {{
            color: #666;
            font-size: 0.85em;
            margin-top: 5px;
        }}
        .stat-good {{ color: #27ae60; }}
        .stat-warning {{ color: #f39c12; }}
        .stat-danger {{ color: #e74c3c; }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }}
        th, td {{
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }}
        th {{
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }}
        tr:hover {{
            background: #f8f9fa;
        }}
        .user-rank {{
            width: 30px;
            text-align: center;
        }}
        .rank-1 {{ color: #f1c40f; font-weight: bold; }}
        .rank-2 {{ color: #95a5a6; font-weight: bold; }}
        .rank-3 {{ color: #cd6133; font-weight: bold; }}
    </style>
</head>
<body>
    <h1>\U0001F4CA Slurm Cluster Sitrep</h1>
    <p class="timestamp">Generated: {timestamp}</p>
    
    <div class="section">
        <h2>\U0001F5A5 Node Status</h2>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value">{nodes['total']}</div>
                <div class="stat-label">Total Nodes</div>
            </div>
            <div class="stat-box">
                <div class="stat-value stat-good">{nodes['allocated']}</div>
                <div class="stat-label">Allocated</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" style="color:#3498db;">{nodes['mixed']}</div>
                <div class="stat-label">Mixed</div>
            </div>
            <div class="stat-box">
                <div class="stat-value stat-good">{nodes['idle']}</div>
                <div class="stat-label">Idle</div>
            </div>
            <div class="stat-box">
                <div class="stat-value stat-warning">{nodes['drain']}</div>
                <div class="stat-label">Draining</div>
            </div>
            <div class="stat-box">
                <div class="stat-value stat-danger">{nodes['down']}</div>
                <div class="stat-label">Down</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h2>\U0001F4CB Job Queue</h2>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value stat-good">{jobs['running']}</div>
                <div class="stat-label">Running</div>
            </div>
            <div class="stat-box">
                <div class="stat-value stat-warning">{jobs['pending']}</div>
                <div class="stat-label">Pending</div>
            </div>
            <div class="stat-box">
                <div class="stat-value">{jobs['total']}</div>
                <div class="stat-label">Total</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h2>\U0001F4BB Resources In Use (Running Jobs)</h2>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value">{res['cpus']}</div>
                <div class="stat-label">CPUs</div>
            </div>
            <div class="stat-box">
                <div class="stat-value">{res['memory_human']}</div>
                <div class="stat-label">Memory</div>
            </div>
            <div class="stat-box">
                <div class="stat-value">{res['gpus']}</div>
                <div class="stat-label">GPUs</div>
            </div>
        </div>
    </div>
"""
    
    # Top users section
    if top_users:
        html += """    <div class="section">
        <h2>\U0001F3C6 Top 3 Users (by running jobs)</h2>
        <table>
            <tr>
                <th class="user-rank">#</th>
                <th>User</th>
                <th>Jobs</th>
                <th>CPUs</th>
                <th>Memory</th>
                <th>GPUs</th>
            </tr>
"""
        for i, user in enumerate(top_users, 1):
            rank_class = f"rank-{i}" if i <= 3 else ""
            mem = _format_memory_short(user['memory'])
            html += f"""            <tr>
                <td class="user-rank {rank_class}">{i}</td>
                <td>{user['user']}</td>
                <td>{user['running_jobs']}</td>
                <td>{user['cpus']}</td>
                <td>{mem}</td>
                <td>{user['gpus']}</td>
            </tr>
"""
        html += """        </table>
    </div>
"""
    
    # Partition breakdown
    if partitions:
        html += """    <div class="section">
        <h2>\U0001F4C1 Partition Breakdown</h2>
        <table>
            <tr>
                <th>Partition</th>
                <th>Running</th>
                <th>Pending</th>
                <th>CPUs</th>
                <th>Memory</th>
                <th>GPUs</th>
            </tr>
"""
        for part_name, part_data in sorted(partitions.items()):
            mem = _format_memory_short(part_data['memory'])
            html += f"""            <tr>
                <td>{part_name}</td>
                <td>{part_data['running']}</td>
                <td>{part_data['pending']}</td>
                <td>{part_data['cpus']}</td>
                <td>{mem}</td>
                <td>{part_data['gpus']}</td>
            </tr>
"""
        html += """        </table>
    </div>
"""
    
    html += """</body>
</html>
"""
    return html


def _format_sitrep_markdown(data: Dict[str, Any]) -> str:
    """Format sitrep as Markdown."""
    timestamp = datetime.fromisoformat(data['timestamp']).strftime("%Y-%m-%d %H:%M:%S")
    nodes = data['nodes']
    jobs = data['jobs']
    res = data['resources_requested']
    top_users = data['top_users']
    partitions = data.get('partitions', {})
    
    lines = []
    lines.append(f"# \U0001F4CA Slurm Cluster Sitrep")
    lines.append("")
    lines.append(f"**Generated:** {timestamp}")
    lines.append("")
    
    # Node status
    lines.append("## \U0001F5A5 Node Status")
    lines.append("")
    lines.append("| Status | Count | Description |")
    lines.append("|--------|------:|-------------|")
    lines.append(f"| Total | {nodes['total']} | All nodes |")
    lines.append(f"| Allocated | {nodes['allocated']} | Fully allocated |")
    lines.append(f"| Mixed | {nodes['mixed']} | Partially allocated |")
    lines.append(f"| Idle | {nodes['idle']} | Available |")
    lines.append(f"| Drain | {nodes['drain']} | Draining/drained |")
    lines.append(f"| Down | {nodes['down']} | Unavailable |")
    if nodes['reserved'] > 0:
        lines.append(f"| Reserved | {nodes['reserved']} | Reserved |")
    if nodes['other'] > 0:
        lines.append(f"| Other | {nodes['other']} | Other states |")
    lines.append("")
    
    # Job queue
    lines.append("## \U0001F4CB Job Queue")
    lines.append("")
    lines.append("| Status | Count |")
    lines.append("|--------|------:|")
    lines.append(f"| Running | {jobs['running']} |")
    lines.append(f"| Pending | {jobs['pending']} |")
    lines.append(f"| Total | {jobs['total']} |")
    lines.append("")
    
    # Resources in use
    lines.append("## \U0001F4BB Resources In Use (Running Jobs)")
    lines.append("")
    lines.append("| Resource | Amount |")
    lines.append("|----------|-------:|")
    lines.append(f"| CPUs | {res['cpus']} |")
    lines.append(f"| Memory | {res['memory_human']} |")
    lines.append(f"| GPUs | {res['gpus']} |")
    lines.append("")
    
    # Top users
    if top_users:
        lines.append("## \U0001F3C6 Top 3 Users (by running jobs)")
        lines.append("")
        lines.append("| # | User | Jobs | CPUs | Memory | GPUs |")
        lines.append("|---|------|-----:|-----:|-------:|-----:|")
        for i, user in enumerate(top_users, 1):
            mem = _format_memory_short(user['memory'])
            lines.append(f"| {i} | {user['user']} | {user['running_jobs']} | {user['cpus']} | {mem} | {user['gpus']} |")
        lines.append("")
    
    # Partition breakdown
    if partitions:
        lines.append("## \U0001F4C1 Partition Breakdown")
        lines.append("")
        lines.append("| Partition | Running | Pending | CPUs | Memory | GPUs |")
        lines.append("|-----------|--------:|--------:|-----:|-------:|-----:|")
        for part_name, part_data in sorted(partitions.items()):
            mem = _format_memory_short(part_data['memory'])
            lines.append(f"| {part_name} | {part_data['running']} | {part_data['pending']} | {part_data['cpus']} | {mem} | {part_data['gpus']} |")
        lines.append("")
    
    return "\n".join(lines)


def _format_sitrep_mdhtml(data: Dict[str, Any]) -> str:
    """Format sitrep as Markdown with embedded HTML for enhanced display."""
    timestamp = datetime.fromisoformat(data['timestamp']).strftime("%y-%m-%d %H:%M:%S")
    nodes = data['nodes']
    jobs = data['jobs']
    res = data['resources_requested']
    res_total = data.get('resources_total', {'cpus': 0, 'memory_bytes': 0, 'memory_human': '0', 'gpus': 0})
    res_pct = data.get('resources_pct', {'cpus': 0, 'memory': 0, 'gpus': 0})
    top_users = data['top_users']
    partitions = data.get('partitions', {})
    
    # Build top users summary string
    top_users_summary = "None" if not top_users else ", ".join([u['user'] for u in top_users[:3]])
    
    # Color class based on utilization percentage
    def pct_class(pct):
        if pct >= 80:
            return 'sr-good'
        elif pct >= 50:
            return 'sr-blue'
        else:
            return 'sr-warn'
    
    md = f"""## \U0001F4CA Current Status

<style>
.sr-table {{ border-collapse: collapse; }}
.sr-table th {{ background: #005f85; color: white; padding: 8px 12px; text-align: left; white-space: nowrap; }}
.sr-table td {{ padding: 8px 12px; border-bottom: 1px solid #ddd; white-space: nowrap; }}
.sr-table tr:hover {{ background: #f5f5f5; }}
.sr-good {{ color: #28a745; font-weight: bold; }}
.sr-warn {{ color: #f39c12; font-weight: bold; }}
.sr-bad {{ color: #e74c3c; font-weight: bold; }}
.sr-val {{ font-weight: bold; }}
.sr-blue {{ color: #3498db; font-weight: bold; }}
details {{ margin-bottom: 8px; }}
details > summary {{ background: #005f85; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; list-style: none; }}
details > summary::-webkit-details-marker {{ display: none; }}
details > summary::before {{ content: '‚ñ∂ '; font-size: 0.8em; }}
details[open] > summary {{ border-radius: 4px 4px 0 0; }}
details[open] > summary::before {{ content: '‚ñº '; }}
details > summary .sr-good {{ color: #90EE90; }}
details > summary .sr-warn {{ color: #FFD700; }}
details > summary .sr-bad {{ color: #FF6B6B; }}
details > summary .sr-blue {{ color: #87CEEB; }}
</style>

<table class="sr-table">
<tr><th>Resource</th><th>In Use</th><th>Total</th><th>%</th></tr>
<tr><td>CPUs</td><td class="sr-val">{res['cpus']}</td><td>{res_total['cpus']}</td><td class="{pct_class(res_pct['cpus'])}">{res_pct['cpus']:.1f}%</td></tr>
<tr><td>Memory</td><td class="sr-val">{res['memory_human']}</td><td>{res_total['memory_human']}</td><td class="{pct_class(res_pct['memory'])}">{res_pct['memory']:.1f}%</td></tr>
<tr><td>GPUs</td><td class="sr-val">{res['gpus']}</td><td>{res_total['gpus']}</td><td class="{pct_class(res_pct['gpus'])}">{res_pct['gpus']:.1f}%</td></tr>
</table>

<details>
<summary>\U0001F5A5 <strong>Nodes</strong> ‚Äî {nodes['total']} total (<span class="sr-good">{nodes['idle']}</span> idle, <span class="sr-bad">{nodes['down']}</span> down)</summary>
<table class="sr-table">
<tr><th>State</th><th>Count</th><th>Description</th></tr>
<tr><td>Total</td><td class="sr-val">{nodes['total']}</td><td>All nodes in cluster</td></tr>
<tr><td>Allocated</td><td class="sr-good">{nodes['allocated']}</td><td>Fully allocated</td></tr>
<tr><td>Mixed</td><td class="sr-blue">{nodes['mixed']}</td><td>Partially allocated</td></tr>
<tr><td>Idle</td><td class="sr-good">{nodes['idle']}</td><td>Available for jobs</td></tr>
<tr><td>Drain</td><td class="sr-warn">{nodes['drain']}</td><td>Draining or drained</td></tr>
<tr><td>Down</td><td class="sr-bad">{nodes['down']}</td><td>Unavailable</td></tr>
</table>
</details>

<details>
<summary>\U0001F4CB <strong>Jobs</strong> ‚Äî <span class="sr-good">{jobs['running']}</span> running, <span class="sr-warn">{jobs['pending']}</span> pending</summary>
<table class="sr-table">
<tr><th>State</th><th>Count</th></tr>
<tr><td>Running</td><td class="sr-good">{jobs['running']}</td></tr>
<tr><td>Pending</td><td class="sr-warn">{jobs['pending']}</td></tr>
<tr><td>Total</td><td class="sr-val">{jobs['total']}</td></tr>
</table>
</details>

<details>
<summary>\U0001F3C6 <strong>Top Users</strong> ‚Äî {top_users_summary}</summary>
"""
    
    if top_users:
        md += """<table class="sr-table">
<tr><th>#</th><th>User</th><th>Jobs</th><th>CPUs</th><th>Memory</th><th>GPUs</th></tr>
"""
        for i, user in enumerate(top_users, 1):
            mem = _format_memory_short(user['memory'])
            md += f"<tr><td>{i}</td><td>{user['user']}</td><td>{user['running_jobs']}</td><td>{user['cpus']}</td><td>{mem}</td><td>{user['gpus']}</td></tr>\n"
        md += "</table>\n"
    else:
        md += "<p style=\"color: #666;\">No running jobs</p>\n"
    
    md += "</details>\n"
    
    # Partition breakdown
    if partitions:
        num_partitions = len(partitions)
        md += f"""
<details>
<summary>\U0001F4C1 <strong>Partitions</strong> ‚Äî {num_partitions} partition{"s" if num_partitions != 1 else ""}</summary>
<table class="sr-table">
<tr><th>Partition</th><th>Running</th><th>Pending</th><th>CPUs</th><th>Memory</th><th>GPUs</th></tr>
"""
        for part_name, part_data in sorted(partitions.items()):
            mem = _format_memory_short(part_data['memory'])
            md += f"<tr><td>{part_name}</td><td>{part_data['running']}</td><td>{part_data['pending']}</td><td>{part_data['cpus']}</td><td>{mem}</td><td>{part_data['gpus']}</td></tr>\n"
        md += """</table>
</details>
"""
    
    # Node details breakdown
    node_details = data.get('node_details', [])
    if node_details:
        num_nodes = len(node_details)
        md += f"""
<details>
<summary>\U0001F4E6 <strong>Node Details</strong> ‚Äî {num_nodes} node{"s" if num_nodes != 1 else ""}</summary>
<table class="sr-table">
<tr><th>Node</th><th>State</th><th>CPUs Free</th><th>Mem Free</th><th>GPUs Free</th></tr>
"""
        for node in node_details:
            mem_avail = _format_memory_short(node['mem_avail_mb'] * 1024 * 1024)
            
            # Color code state
            state = node['state']
            if 'idle' in state:
                state_class = 'sr-good'
            elif 'mix' in state:
                state_class = 'sr-blue'
            elif 'alloc' in state:
                state_class = 'sr-warn'
            elif 'down' in state or 'drain' in state:
                state_class = 'sr-bad'
            else:
                state_class = ''
            
            # Format GPU display - show free count or "-" if no GPUs on node
            if node['gpus_total'] > 0:
                gpu_str = str(node['gpus_avail'])
            else:
                gpu_str = "-"
            
            md += f"<tr><td>{node['name']}</td><td class=\"{state_class}\">{state}</td><td>{node['cpus_avail']}</td><td>{mem_avail}</td><td>{gpu_str}</td></tr>\n"
        md += """</table>
</details>
"""
    
    # Timestamp footer
    md += f"""
<p style="font-size: 0.8em; color: #888; margin-top: 10px;">Generated: {timestamp}</p>
"""
    
    return md


def cmd_report(args: argparse.Namespace) -> int:
    """Generate efficiency report for a time period."""
    config = load_config(args.config)
    
    # Calculate date range
    end_date = datetime.now()
    if args.end:
        try:
            end_date = datetime.strptime(args.end, "%Y-%m-%d")
        except ValueError:
            print(f"Error: Invalid end date format. Use YYYY-MM-DD", file=sys.stderr)
            return 1
    
    if args.start:
        try:
            start_date = datetime.strptime(args.start, "%Y-%m-%d")
        except ValueError:
            print(f"Error: Invalid start date format. Use YYYY-MM-DD", file=sys.stderr)
            return 1
    else:
        start_date = end_date - timedelta(days=args.days)
    
    start_str = start_date.strftime("%Y-%m-%d")
    end_str = end_date.strftime("%Y-%m-%d")
    
    # Build title
    title_parts = ["Job Efficiency Report"]
    if args.user:
        title_parts.append(f"User: {args.user}")
    if args.account:
        title_parts.append(f"Account: {args.account}")
    if args.partition:
        title_parts.append(f"Partition: {args.partition}")
    title_parts.append(f"{start_str} to {end_str}")
    title = " | ".join(title_parts)
    
    # Query jobs
    if not args.quiet:
        print(f"Querying jobs from {start_str} to {end_str}...", file=sys.stderr)
    
    jobs = _query_jobs_for_report(
        config,
        start_str,
        end_str,
        user=args.user,
        account=args.account,
        partition=args.partition,
    )
    
    if not jobs:
        print("No jobs found in the specified time period.", file=sys.stderr)
        return 1
    
    if not args.quiet:
        print(f"Found {len(jobs)} jobs. Calculating statistics...", file=sys.stderr)
    
    # Calculate stats
    stats = _calculate_report_stats(jobs, config)
    
    # Format output
    if args.format == 'json':
        output = _format_report_json(stats)
    elif args.format == 'csv':
        output = _format_report_csv(stats, jobs, config)
    elif args.format == 'html':
        output = _format_report_html(stats, title)
    else:
        output = _format_report_text(stats, title)
    
    # Write output
    if args.output:
        with open(args.output, 'w') as f:
            f.write(output)
        if not args.quiet:
            print(f"Report written to {args.output}", file=sys.stderr)
    else:
        print(output)
    
    return 0


def cmd_status(args: argparse.Namespace) -> int:
    """Show efficiency status of a job."""
    config = load_config(args.config)
    job_stats = JobStats(config)
    metrics = job_stats.get_job_stats(args.job_id)

    if metrics is None:
        print(f"Error: Could not get status for job {args.job_id}", file=sys.stderr)
        return 1

    print(f"\n{'='*50}")
    print(f"Job {metrics.job_id}: {metrics.job_name or 'N/A'}")
    print(f"{'='*50}")
    print(f"User:       {metrics.user}")
    print(f"State:      {metrics.state.value}")
    print(f"Partition:  {metrics.partition}")

    print(f"\n--- Resources ---")
    print(f"Nodes:      {metrics.num_nodes}")
    print(f"CPUs:       {metrics.num_cpus}")
    if metrics.has_gpus:
        print(f"GPUs:       {metrics.num_gpus}")
    print(f"Memory:     {metrics.memory_requested_gb:.1f} GB requested")

    print(f"\n--- Efficiency ---")
    cpu_bar = _make_bar(metrics.cpu_efficiency)
    mem_bar = _make_bar(metrics.memory_efficiency)
    print(f"CPU:        {cpu_bar} {metrics.cpu_efficiency:5.1f}%")
    print(f"Memory:     {mem_bar} {metrics.memory_efficiency:5.1f}% (peak: {metrics.memory_used_max_gb:.1f} GB)")
    if metrics.has_gpus:
        gpu_bar = _make_bar(metrics.gpu_utilization_avg)
        print(f"GPU:        {gpu_bar} {metrics.gpu_utilization_avg:5.1f}%")

    print(f"\n--- Time ---")
    elapsed = str(metrics.elapsed_time).split('.')[0]
    limit = str(metrics.time_limit).split('.')[0]
    time_bar = _make_bar(metrics.time_efficiency)
    print(f"Elapsed:    {elapsed}")
    print(f"Limit:      {limit}")
    print(f"Used:       {time_bar} {metrics.time_efficiency:5.1f}%")

    recommendations = _get_recommendations(metrics, config)
    if recommendations:
        print(f"\n--- Recommendations ---")
        for rec in recommendations:
            print(f"  ‚Ä¢ {rec}")

    print()

    if args.json:
        data = {
            'job_id': metrics.job_id,
            'job_name': metrics.job_name,
            'user': metrics.user,
            'state': metrics.state.value,
            'partition': metrics.partition,
            'num_nodes': metrics.num_nodes,
            'num_cpus': metrics.num_cpus,
            'num_gpus': metrics.num_gpus,
            'memory_requested_gb': metrics.memory_requested_gb,
            'memory_used_max_gb': metrics.memory_used_max_gb,
            'cpu_efficiency': metrics.cpu_efficiency,
            'memory_efficiency': metrics.memory_efficiency,
            'gpu_utilization': metrics.gpu_utilization_avg if metrics.has_gpus else None,
            'elapsed_seconds': metrics.elapsed_seconds,
            'time_limit_seconds': metrics.time_limit_seconds,
            'time_efficiency': metrics.time_efficiency,
        }
        print("JSON:")
        print(json.dumps(data, indent=2))

    return 0


def cmd_update(args: argparse.Namespace) -> int:
    """Update OOD session card for a job."""
    config = load_config(args.config)
    job_stats = JobStats(config)
    card_updater = SessionCardUpdater(config)
    metrics = job_stats.get_job_stats(args.job_id)

    if metrics is None:
        print(f"Error: Could not get metrics for job {args.job_id}", file=sys.stderr)
        return 1

    if args.session_path:
        session_path = Path(args.session_path)
    else:
        user = args.user or metrics.user
        session_path = card_updater.find_session_for_job(user, args.job_id)
        if session_path is None:
            print(f"Error: Could not find OOD session for job {args.job_id}", file=sys.stderr)
            print("Use --session-path to specify the session directory", file=sys.stderr)
            return 1

    success = card_updater.update_session_card(session_path, metrics)
    if success:
        print(f"Updated session card: {session_path / 'info.html'}")
        return 0
    else:
        print("Error: Failed to update session card", file=sys.stderr)
        return 1


def cmd_list(args: argparse.Namespace) -> int:
    """List active OOD sessions."""
    config = load_config(args.config)
    card_updater = SessionCardUpdater(config)
    job_stats = JobStats(config)
    username = args.user or pwd.getpwuid(os.getuid()).pw_name
    sessions = card_updater.list_active_sessions(username)

    if not sessions:
        print(f"No active OOD sessions found for user {username}")
        return 0

    print(f"\nActive Sessions for {username}")
    print(f"{'Job ID':<12} {'State':<12} {'CPU %':<8} {'Mem %':<8} {'Session'}")
    print("-" * 60)

    for session_path, job_id in sessions:
        metrics = job_stats.get_job_stats(job_id)
        if metrics:
            state = metrics.state.value[:10]
            cpu = f"{metrics.cpu_efficiency:.1f}" if metrics.cpu_efficiency > 0 else "-"
            mem = f"{metrics.memory_efficiency:.1f}" if metrics.memory_efficiency > 0 else "-"
        else:
            state = "UNKNOWN"
            cpu = "-"
            mem = "-"
        print(f"{job_id:<12} {state:<12} {cpu:<8} {mem:<8} {session_path.name}")

    print()
    return 0


def cmd_html(args: argparse.Namespace) -> int:
    """Generate HTML card for a job."""
    config = load_config(args.config)
    job_stats = JobStats(config)
    card_updater = SessionCardUpdater(config)
    metrics = job_stats.get_job_stats(args.job_id)

    if metrics is None:
        print(f"Error: Could not get metrics for job {args.job_id}", file=sys.stderr)
        return 1

    html = card_updater.generate_card_html(metrics)
    if args.output:
        with open(args.output, 'w') as f:
            f.write(html)
        print(f"HTML written to {args.output}")
    else:
        print(html)

    return 0


def create_parser() -> argparse.ArgumentParser:
    """Create the argument parser."""
    parser = argparse.ArgumentParser(
        prog='schmutz',
        description='Display Slurm job efficiency metrics (like jobstats/jobperf)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  schmutz 12345                        Show efficiency for job 12345
  schmutz status 12345                 Same as above
  schmutz update 12345                 Update OOD session card for job
  schmutz list                         List active OOD sessions
  schmutz html 12345                   Output HTML card to stdout

  schmutz report                       Weekly report for current user
  schmutz report --days 7              Last 7 days (default)
  schmutz report --user jsmith         Report for specific user
  schmutz report --account physics     Report for account/group
  schmutz report --format html -o r.html  Generate HTML report
  schmutz report --start 2026-01-01 --end 2026-01-31  Custom date range

  schmutz leaderboard                  Rank all users by efficiency (7 days)
  schmutz leaderboard --days 30        Last 30 days
  schmutz leaderboard --sort waste     Rank by CPU hours wasted
  schmutz leaderboard --min-jobs 5     Only users with 5+ jobs

  schmutz sitrep                       Show cluster status overview
  schmutz sitrep --format json         Output as JSON
  schmutz sitrep --format html -o status.html  Generate HTML report
"""
    )

    parser.add_argument('--version', '-V', action='version', version=f'%(prog)s {__version__}')
    parser.add_argument('--config', '-c', help='Path to configuration file')
    parser.add_argument('--verbose', '-v', action='store_true', help='Enable verbose output')
    parser.add_argument('--debug', action='store_true', help='Enable debug output')
    parser.add_argument('--json', '-j', action='store_true', help='Output JSON')

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    status_parser = subparsers.add_parser('status', help='Show job efficiency status')
    status_parser.add_argument('job_id', help='Slurm job ID')
    status_parser.add_argument('--json', '-j', action='store_true', help='Output JSON')
    status_parser.set_defaults(func=cmd_status)

    update_parser = subparsers.add_parser('update', help='Update OOD session card')
    update_parser.add_argument('job_id', help='Slurm job ID')
    update_parser.add_argument('--session-path', '-s', help='Path to OOD session directory')
    update_parser.add_argument('--user', '-u', help='Username for finding session')
    update_parser.set_defaults(func=cmd_update)

    list_parser = subparsers.add_parser('list', help='List active OOD sessions')
    list_parser.add_argument('--user', '-u', help='User to list sessions for')
    list_parser.set_defaults(func=cmd_list)

    html_parser = subparsers.add_parser('html', help='Generate HTML card')
    html_parser.add_argument('job_id', help='Slurm job ID')
    html_parser.add_argument('--output', '-o', help='Output file (default: stdout)')
    html_parser.set_defaults(func=cmd_html)

    # Report subcommand
    report_parser = subparsers.add_parser('report', help='Generate efficiency report')
    report_parser.add_argument('--days', '-d', type=int, default=7,
                               help='Number of days to include (default: 7)')
    report_parser.add_argument('--start', help='Start date (YYYY-MM-DD)')
    report_parser.add_argument('--end', help='End date (YYYY-MM-DD, default: today)')
    report_parser.add_argument('--user', '-u', help='Filter by username')
    report_parser.add_argument('--account', '-a', help='Filter by Slurm account')
    report_parser.add_argument('--partition', '-p', help='Filter by partition')
    report_parser.add_argument('--format', '-f', choices=['text', 'json', 'csv', 'html'],
                               default='text', help='Output format (default: text)')
    report_parser.add_argument('--output', '-o', help='Output file (default: stdout)')
    report_parser.add_argument('--quiet', '-q', action='store_true',
                               help='Suppress progress messages')
    report_parser.set_defaults(func=cmd_report)

    # Leaderboard subcommand
    lb_parser = subparsers.add_parser('leaderboard', help='Rank users by efficiency')
    lb_parser.add_argument('--days', '-d', type=int, default=1,
                           help='Number of days to include (default: 1)')
    lb_parser.add_argument('--account', '-a', help='Filter by Slurm account')
    lb_parser.add_argument('--partition', '-p', help='Filter by partition')
    lb_parser.add_argument('--sort', '-s', choices=['efficiency', 'cpu', 'memory', 'jobs'],
                           default='efficiency', help='Sort by (default: efficiency)')
    lb_parser.add_argument('--top', '-t', type=int, help='Show only top N users (best efficiency)')
    lb_parser.add_argument('--bottom', '-b', type=int, help='Show only bottom N users (worst efficiency)')
    lb_parser.add_argument('--show-both', '-B', metavar='N', type=int,
                           help='Show both top N and bottom N users')
    lb_parser.add_argument('--min-jobs', '-m', type=int, default=0,
                           help='Minimum jobs to be included (default: 0)')
    lb_parser.add_argument('--format', '-f', choices=['text', 'json', 'html', 'markdown', 'mdhtml'],
                           default='text', help='Output format (default: text)')
    lb_parser.add_argument('--output', '-o', help='Output file (default: stdout)')
    lb_parser.add_argument('--quiet', '-q', action='store_true',
                           help='Suppress progress messages')
    lb_parser.set_defaults(func=cmd_leaderboard)

    # Sitrep subcommand - cluster status overview
    sitrep_parser = subparsers.add_parser('sitrep', help='Show cluster status overview')
    sitrep_parser.add_argument('--format', '-f', choices=['text', 'json', 'html', 'markdown', 'mdhtml'],
                               default='text', help='Output format (default: text)')
    sitrep_parser.add_argument('--output', '-o', help='Output file (default: stdout)')
    sitrep_parser.add_argument('--quiet', '-q', action='store_true',
                               help='Suppress progress messages')
    sitrep_parser.set_defaults(func=cmd_sitrep)

    return parser


def main() -> int:
    """Main entry point."""
    # Check if first non-flag argument looks like a job ID (numeric)
    # This allows "schmutz 12345" as shorthand for "schmutz status 12345"
    argv = sys.argv[1:]
    
    # Find first positional argument (skip flags)
    i = 0
    while i < len(argv):
        arg = argv[i]
        if arg.startswith('-'):
            # Skip flag and its value if it takes one
            if arg in ('-c', '--config', '-o', '--output', '-s', '--session-path', '-u', '--user'):
                i += 2
            else:
                i += 1
        else:
            # Found positional argument
            if arg.isdigit() or (arg.replace('_', '').isdigit()):
                # Looks like a job ID, insert 'status' command
                argv.insert(i, 'status')
            break
    
    parser = create_parser()
    args = parser.parse_args(argv)

    setup_logging(verbose=args.verbose, debug=args.debug)

    if args.command is None:
        parser.print_help()
        return 0

    # Verify job_id for commands that require it
    if args.command in ('status', 'update', 'html'):
        if not hasattr(args, 'job_id') or not args.job_id:
            print(f"Error: job_id is required for '{args.command}' command", file=sys.stderr)
            return 1

    return args.func(args)


if __name__ == '__main__':
    sys.exit(main())
